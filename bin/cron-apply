#!/bin/bash
# shellcheck disable=SC2004

set -eu

VERSION="not set"

FULL_PATH=$(dirname "$(realpath "$0")")
CRON_FILE="$FULL_PATH/../raspberrypi/schedules.cron"
PRIVATE_CRON_FILE="$FULL_PATH/../raspberrypi/private/schedules.cron"

CRON_API_URL="https://api.github.com/repos/noraworld/cron-conf/contents/raspberrypi/schedules.cron"
PRIVATE_CRON_API_URL="https://api.github.com/repos/noraworld/envsman/contents/raspberrypi/cron-conf/private/schedules.cron"

JUDGE_FILEPATH="/etc/dnsmasq.toggle/youtube.conf"

main() {
  parse "$@"
  eval "set -- $REST"
  mode="$1"

  # It may be unnecessary because there is an observer to prevent the
  # cron config file from being modified in the daytime
  # judge

  case "$mode" in
    "check")
      check "$@"
      ;;
    "perform")
      [ "$SKIP" = 1 ] || check "$@"
      perform "$@"
      ;;
    *)
      echo "error: no such mode: \"$mode\"" >&2
      exit 1
      ;;
  esac
}

check() {
  local_cron_conf="$(print_conf "$CRON_FILE" "$PRIVATE_CRON_FILE")"

  # It is advisable to exit if there is no need to update schedules
  # because the limit of GitHub API requests may be exceeded
  if [ "$(diff <(crontab -l) <(echo "$local_cron_conf"))" = "" ]; then
    # No need to update because current and local cron configs are the same
    echo "-1"
    exit 1
  fi

  # Invoke the GitHub API
  remote_cron_conf="$(print_conf_remote $CRON_API_URL $PRIVATE_CRON_API_URL)"

  if [ "$(diff <(echo "$local_cron_conf") <(echo "$remote_cron_conf"))" != "" ]; then
    # Cancel updating because local and remote cron configs are different
    echo "-2"
    exit 1
  fi

  echo "1"
}

perform() {
  local_cron_conf="$(print_conf "$CRON_FILE" "$PRIVATE_CRON_FILE")"
  echo "$local_cron_conf" | crontab

  validate_failed=false
  validate "$local_cron_conf" "$(crontab -l)"
  if $validate_failed; then
    exit 1
  fi

  if [ "$DEBUG" = 1 ]; then
    # crontab -l | less
    crontab -l | batcat -l ruby
  fi
}

judge() {
  if [ -e "$JUDGE_FILEPATH" ]; then
    echo "ERROR: Failed to apply cron configurations because \"$JUDGE_FILEPATH\" exists" >&2
    echo "       It can be used only when \"$JUDGE_FILEPATH\" does not exist" >&2
    echo "       But you should not delete it manually because this behavior is to make it difficult to change cron configurations" >&2
    exit 1
  fi

  # TODO: implement additional feature so that it can be only executed via cron
}

validate() {
  if [ "$(diff <(echo "$1") <(echo "$2"))" != "" ]; then
    echo "ERROR: It looks like something went wrong" >&2
    echo >&2
    echo "The diff shows here:" >&2
    diff <(echo "$1") <(echo "$2") >&2
    validate_failed=true
  fi
}

# This should be performed only once
# because the limit of GitHub API requests exceeds
# if they are called too many
print_conf_remote() {
  echo "##### BEGIN PUBLIC CRON CONF #####"
  curl --silent "$(gh api "$1" --jq .download_url)"
  echo "##### END PUBLIC CRON CONF #####"
  echo
  echo
  echo
  echo "##### BEGIN PRIVATE CRON CONF #####"
  curl --silent "$(gh api "$2" --jq .download_url)"
  echo "##### END PRIVATE CRON CONF #####"
}

print_conf() {
  echo "##### BEGIN PUBLIC CRON CONF #####"
  cat "$1"
  echo "##### END PUBLIC CRON CONF #####"
  echo
  echo
  echo
  echo "##### BEGIN PRIVATE CRON CONF #####"
  cat "$2"
  echo "##### END PRIVATE CRON CONF #####"
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: cron-apply [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    DEBUG   -d --debug   -- "show the schedules after applying the changes"
  flag    SKIP    -s --skip    -- "skip the check"
  disp    :usage  -h --help    -- "show help message and exit"
  disp    VERSION    --version -- "show version and exit"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
SKIP=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[dsh]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '-d'|'--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '-s'|'--skip')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SKIP="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: cron-apply [options]... [arguments]...

Options:
  -d, --debug                 show the schedules after applying the changes
  -s, --skip                  skip the check
  -h, --help                  show help message and exit
      --version               show version and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
