#!/bin/sh
# shellcheck disable=SC2004

# Disabled to refresh and log when some command fails
# set -eu

# a troubleshooting log when the network issue was the ISP's fault:
#   https://chatgpt.com/share/68aa8f62-986c-8004-9471-814c3e0c2f83 (2025-08-24)

LOG_PATH="/home/ubuntu/workspace/log/pi/log/ip-observer"
SLEEP_AFTER_NETPLAN_APPLY_INTERVAL="5"
PING_COUNT="1"
PING_WAIT="10"
GLOBAL_IP="8.8.8.8"

main() {
  parse "$@"
  eval "set -- $REST"

  networkd_aliver
  routing_exists
  addresses_exist
  check_connectivity

  [ "$DEBUG" = 1 ] && print_log "0" "nothing wrong was detected"
}

daemon_alive() {
  daemon="$1"
  code="$2"

  if [ "$(systemctl is-active  "$daemon")" != "active"  ] ||
     [ "$(systemctl is-enabled "$daemon")" != "enabled" ]
  then
    print_log "$code" "$daemon was not active or enabled"
    sudo systemctl unmask "$daemon"
    sudo systemctl enable "$daemon"
    sudo systemctl start  "$daemon"
  fi
}

daemon_dead() {
  daemon="$1"
  code="$2"

  if [ "$(systemctl is-active  "$daemon")" != "inactive" ] ||
     [ "$(systemctl is-enabled "$daemon")" != "disabled" ]
  then
    print_log "$code" "$daemon was not inactive or disabled"
    sudo systemctl mask    "$daemon"
    sudo systemctl disable "$daemon"
    sudo systemctl stop    "$daemon"
  fi
}

routing_exists() {
  nic="$1"
  code="$2"

  if [ "$(ip route show dev "$nic")" = "" ]; then
    print_log "$code" "routing for $nic was lost"
    refresh_netplan
  fi
}

address_exists() {
  nic="$1"
  code="$2"

  ip_address=$(ip -f inet address show "$nic" | grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[^255]" || true)

  if [ "$ip_address" = "" ]; then
    print_log "$code" "the address for $nic was not found (perhaps it's the upstream router's or DHCP server's, or the ISP's fault)"
    renew_ip_address "$nic"
  fi
}

address_valid() {
  nic="$1"
  code="$2"

  expected_ip=$(sudo netplan get ethernets."$nic".addresses | grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[^255]" || true)
  actual_ip=$(ip -f inet address show "$nic" | grep -oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[^255]" || true)

  if [ "$expected_ip" != "$actual_ip" ]; then
    print_log "$code" "the expected IP address for $nic did not match the actual one"
    refresh_netplan
  fi
}

check_connectivity() {
  if ! ping -c "$PING_COUNT" -W "$PING_WAIT" "$GLOBAL_IP" > /dev/null; then
    print_log "4" "sending an ICMP Echo packet to the Internet has failed"
    refresh_netplan
  fi
}

refresh_netplan() {
  sudo netplan apply
  sleep "$SLEEP_AFTER_NETPLAN_APPLY_INTERVAL" # ping fails immediately after "sudo netplan apply"
}

print_log() {
  echo "{ \"code\": $1, \"date\": \"$(date)\", \"reason\": \"$2\" }" >> "$LOG_PATH"
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: ip-observer [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    DEBUG   -d --debug   -- "debug mode"
  disp    :usage  -h --help
  disp    VERSION    --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[dh]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '-d'|'--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: ip-observer [options]... [arguments]...

Options:
  -d, --debug                 debug mode
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
