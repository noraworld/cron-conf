#!/bin/sh

# shellcheck disable=SC2004

STRATEGY="scraping_by"
STRATEGY_FILE="/home/ubuntu/workspace/cron-conf/raspberrypi/config/quotarget.json"
TIMEFRAME_LIST="predawn dawn morning midday afternoon evening night midnight"

RESET_COLOR="\033[m"
OK_COLOR="\033[32m"
NG_COLOR="\033[31m"
DRY_COLOR="\033[33m"

DRY_RUN_STATUS_MARK=-

STANDARD_TODO_PERSONAL=1
STANDARD_TASK_PERSONAL=2
STANDARD_TICK_PERSONAL=1
STANDARD_TODO_WORK=1
STANDARD_TASK_WORK=2
STANDARD_SUM=$(( STANDARD_TODO_PERSONAL + STANDARD_TASK_PERSONAL + STANDARD_TICK_PERSONAL + STANDARD_TODO_WORK + STANDARD_TASK_WORK ))
STANDARD_PRODUCT=$(( STANDARD_TODO_PERSONAL * STANDARD_TASK_PERSONAL * STANDARD_TICK_PERSONAL * STANDARD_TODO_WORK * STANDARD_TASK_WORK ))

main() {
  prepare "$@"
  list_info "$@"
  validate "$@"

  if [ "$FORCE" = "1" ]; then
    force="--force"
  else
    # $force doesn't seem to be used, but it's actually used within quotarget.json
    # shellcheck disable=SC2034
    force=""
  fi

  todo_personal_cmd=$(
    jq ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.todo_personal" "$STRATEGY_FILE" |
    sed -e 's/^"//' -e 's/"$//' -e 's/\\"/"/g'
  )

  task_personal_cmd=$(
    jq ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.task_personal" "$STRATEGY_FILE" |
    sed -e 's/^"//' -e 's/"$//' -e 's/\\"/"/g'
  )

  tick_personal_cmd=$(
    jq ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.tick_personal" "$STRATEGY_FILE" |
    sed -e 's/^"//' -e 's/"$//' -e 's/\\"/"/g'
  )

  todo_work_cmd=$(
    jq ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.todo_work" "$STRATEGY_FILE" |
    sed -e 's/^"//' -e 's/"$//' -e 's/\\"/"/g'
  )

  task_work_cmd=$(
    jq ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.task_work" "$STRATEGY_FILE" |
    sed -e 's/^"//' -e 's/"$//' -e 's/\\"/"/g'
  )

  if [ "$DRY_RUN" = "1" ]; then
    todo_personal_result=$DRY_RUN_STATUS_MARK
    task_personal_result=$DRY_RUN_STATUS_MARK
    tick_personal_result=$DRY_RUN_STATUS_MARK
    todo_work_result=$DRY_RUN_STATUS_MARK
    task_work_result=$DRY_RUN_STATUS_MARK

    sum=$DRY_RUN_STATUS_MARK
    product=$DRY_RUN_STATUS_MARK
  else
    todo_personal_result=$(eval "$todo_personal_cmd")
    task_personal_result=$(eval "$task_personal_cmd")
    tick_personal_result=$(eval "$tick_personal_cmd")
    todo_work_result=$(eval "$todo_work_cmd")
    task_work_result=$(eval "$task_work_cmd")

    sum=$(( todo_personal_result + task_personal_result + tick_personal_result + todo_work_result + task_work_result ))
    product=$(( todo_personal_result * task_personal_result * tick_personal_result * todo_work_result * task_work_result ))
  fi

  [ "$DEBUG" = "1" ] && debug_info

  if [ "$sum" = "$STANDARD_SUM" ] && [ "$product" = "$STANDARD_PRODUCT" ]; then
    echo "1"
  elif [ "$product" = "0" ]; then
    echo "0"
  else
    echo "-1"
  fi
}

prepare() {
  parse "$@"
  eval "set -- $REST"
}

list_info() {
  if [ "$LIST_TIMEFRAMES" = "1" ]; then
    for tf in $TIMEFRAME_LIST; do
      printf '%s\n' "$tf"
    done
    exit 0
  elif [ "$LIST_SERVICES" = "1" ]; then
    jq -r 'keys[]' "$STRATEGY_FILE"
    exit 0
  fi
}

debug_info() {
  if [ "$todo_personal_result" = "$STANDARD_TODO_PERSONAL" ]; then
    todo_personal_result_color="$OK_COLOR"
  elif [ "$todo_personal_result" = "$DRY_RUN_STATUS_MARK" ]; then
    todo_personal_result_color="$DRY_COLOR"
  else
    todo_personal_result_color="$NG_COLOR"
  fi

  if [ "$task_personal_result" = "$STANDARD_TASK_PERSONAL" ]; then
    task_personal_result_color="$OK_COLOR"
  elif [ "$task_personal_result" = "$DRY_RUN_STATUS_MARK" ]; then
    task_personal_result_color="$DRY_COLOR"
  else
    task_personal_result_color="$NG_COLOR"
  fi

  if [ "$tick_personal_result" = "$STANDARD_TICK_PERSONAL" ]; then
    tick_personal_result_color="$OK_COLOR"
  elif [ "$tick_personal_result" = "$DRY_RUN_STATUS_MARK" ]; then
    tick_personal_result_color="$DRY_COLOR"
  else
    tick_personal_result_color="$NG_COLOR"
  fi

  if [ "$todo_work_result" = "$STANDARD_TODO_WORK" ]; then
    todo_work_result_color="$OK_COLOR"
  elif [ "$todo_work_result" = "$DRY_RUN_STATUS_MARK" ]; then
    todo_work_result_color="$DRY_COLOR"
  else
    todo_work_result_color="$NG_COLOR"
  fi

  if [ "$task_work_result" = "$STANDARD_TASK_WORK" ]; then
    task_work_result_color="$OK_COLOR"
  elif [ "$task_work_result" = "$DRY_RUN_STATUS_MARK" ]; then
    task_work_result_color="$DRY_COLOR"
  else
    task_work_result_color="$NG_COLOR"
  fi

  if [ "$sum" = "$STANDARD_SUM" ]; then
    sum_color="$OK_COLOR"
  elif [ "$sum" = "$DRY_RUN_STATUS_MARK" ]; then
    sum_color="$DRY_COLOR"
  else
    sum_color="$NG_COLOR"
  fi

  if [ "$product" = "$STANDARD_PRODUCT" ]; then
    product_color="$OK_COLOR"
  elif [ "$product" = "$DRY_RUN_STATUS_MARK" ]; then
    product_color="$DRY_COLOR"
  else
    product_color="$NG_COLOR"
  fi

  printf  "DEBUG: todo_personal_cmd:     %s\n"                                               "$todo_personal_cmd"                                >&2
  printf  "DEBUG: todo_personal_result:  $todo_personal_result_color%6s (%s)$RESET_COLOR\n"  "$todo_personal_result"  "$STANDARD_TODO_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: task_personal_cmd:     %s\n"                                               "$task_personal_cmd"                                >&2
  printf  "DEBUG: task_personal_result:  $task_personal_result_color%6s (%s)$RESET_COLOR\n"  "$task_personal_result"  "$STANDARD_TASK_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: tick_personal_cmd:     %s\n"                                               "$tick_personal_cmd"                                >&2
  printf  "DEBUG: tick_personal_result:  $tick_personal_result_color%6s (%s)$RESET_COLOR\n"  "$tick_personal_result"  "$STANDARD_TICK_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: todo_work_cmd:         %s\n"                                               "$todo_work_cmd"                                    >&2
  printf  "DEBUG: todo_work_result:      $todo_work_result_color%6s (%s)$RESET_COLOR\n"      "$todo_work_result"      "$STANDARD_TODO_WORK"      >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: task_work_cmd:         %s\n"                                               "$task_work_cmd"                                    >&2
  printf  "DEBUG: task_work_result:      $task_work_result_color%6s (%s)$RESET_COLOR\n"      "$task_work_result"      "$STANDARD_TASK_WORK"      >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: sum:                   $sum_color%6s (%s)$RESET_COLOR\n"                   "$sum"                   "$STANDARD_SUM"            >&2
  printf  "DEBUG: product:               $product_color%6s (%s)$RESET_COLOR\n"               "$product"               "$STANDARD_PRODUCT"        >&2
  printf  "\n"                                                                                                                                   >&2
}

validate() {
  valid_tf=false

  for tf in $TIMEFRAME_LIST; do
    if [ "$TIMEFRAME" = "$tf" ]; then
      valid_tf=true
      break
    fi
  done

  if [ "$valid_tf" != "true" ]; then
    echo "Error: Invalid TIMEFRAME: $TIMEFRAME" >&2
    exit 1
  fi
}

# @getoptions
parser_definition() {
  setup REST help:usage -- "Usage: quotarget [options]... [arguments]..." ''
  msg -- 'Options:'
  flag  DEBUG              --debug           -- "show debug messages"
  flag  DRY_RUN            --dry-run         -- "check only the standard (used when preventing it from calling the APIs)"
  flag  FORCE              --force           -- "get content from APIs even if cache exists"
  flag  LIST_TIMEFRAMES    --list-timeframes -- "get list of timeframes"
  flag  LIST_SERVICES      --list-services   -- "get list of services"
  param SERVICE            --service         -- "youtube, vod, ..."
  param TIMEFRAME          --timeframe       -- "timeframe"
  disp  :usage          -h --help
  disp  VERSION            --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
DRY_RUN=''
FORCE=''
LIST_TIMEFRAMES=''
LIST_SERVICES=''
SERVICE=''
TIMEFRAME=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '--dry-run')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DRY_RUN="$OPTARG"
        ;;
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--list-timeframes')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        LIST_TIMEFRAMES="$OPTARG"
        ;;
      '--list-services')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        LIST_SERVICES="$OPTARG"
        ;;
      '--service')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        SERVICE="$OPTARG"
        shift ;;
      '--timeframe')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TIMEFRAME="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: quotarget [options]... [arguments]...

Options:
      --debug                 show debug messages
      --dry-run               check only the standard (used when preventing it from calling the APIs)
      --force                 get content from APIs even if cache exists
      --list-timeframes       get list of timeframes
      --list-services         get list of services
      --service SERVICE       youtube, vod, ...
      --timeframe TIMEFRAME   timeframe
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
