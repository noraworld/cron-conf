#!/bin/sh

# shellcheck disable=SC2004

STRATEGY="scraping_by"
STRATEGY_FILE="/home/ubuntu/workspace/cron-conf/raspberrypi/config/quotarget.json"
INHERIT_KEYWORD_REGEXP="^INHERIT "

# The number of elements and the order of each element for TIMEFRAME_LIST and TIMEFRAME_BOUNDARIES must match.
TIMEFRAME_LIST="qtg0000 qtg0100 qtg0200 qtg0300 qtg0400 qtg0500 qtg0600 qtg0700 qtg0800 qtg0900 qtg1000 qtg1100 qtg1200 qtg1300 qtg1400 qtg1500 qtg1600 qtg1700 qtg1800 qtg1900 qtg2000 qtg2100 qtg2200 qtg2300"
TIMEFRAME_BOUNDARIES="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
TIMEFRAME_RELATIVE_LIST="prev now next"

RESET_COLOR="\033[m"
OK_COLOR="\033[32m"
NG_COLOR="\033[31m"
DRY_COLOR="\033[33m"

DRY_RUN_RESULT=-

STANDARD_TODO_PERSONAL=1
STANDARD_TASK_PERSONAL=1
STANDARD_TICK_PERSONAL=1
STANDARD_TODO_WORK=1
STANDARD_TASK_WORK=1
STANDARD_SUM=$(( STANDARD_TODO_PERSONAL + STANDARD_TASK_PERSONAL + STANDARD_TICK_PERSONAL + STANDARD_TODO_WORK + STANDARD_TASK_WORK ))
STANDARD_PRODUCT=$(( STANDARD_TODO_PERSONAL * STANDARD_TASK_PERSONAL * STANDARD_TICK_PERSONAL * STANDARD_TODO_WORK * STANDARD_TASK_WORK ))

main() {
  prepare "$@"
  list_info "$@"
  convert_timeframe_relative "$@"
  validate "$@"

  if [ "$FORCE" = "1" ]; then
    force="--force"
  else
    # $force doesn't seem to be used, but it's actually used within quotarget.json
    # shellcheck disable=SC2034
    force=""
  fi

  if [ "$CACHE_ONLY" = "1" ]; then
    cache_only="--cache-only"
  else
    # same as $force
    # shellcheck disable=SC2034
    cache_only=""
  fi

  todo_personal_cmd=$(get_cmd "todo_personal")
  task_personal_cmd=$(get_cmd "task_personal")
  tick_personal_cmd=$(get_cmd "tick_personal")
  todo_work_cmd=$(get_cmd "todo_work")
  task_work_cmd=$(get_cmd "task_work")

  if [ "$DRY_RUN" = "1" ]; then
    todo_personal_result=$DRY_RUN_RESULT
    task_personal_result=$DRY_RUN_RESULT
    tick_personal_result=$DRY_RUN_RESULT
    todo_work_result=$DRY_RUN_RESULT
    task_work_result=$DRY_RUN_RESULT

    sum=$DRY_RUN_RESULT
    product=$DRY_RUN_RESULT
  else
    todo_personal_result=$(eval "$todo_personal_cmd")
    task_personal_result=$(eval "$task_personal_cmd")
    tick_personal_result=$(eval "$tick_personal_cmd")
    todo_work_result=$(eval "$todo_work_cmd")
    task_work_result=$(eval "$task_work_cmd")

    sum=$(( todo_personal_result + task_personal_result + tick_personal_result + todo_work_result + task_work_result ))
    product=$(( todo_personal_result * task_personal_result * tick_personal_result * todo_work_result * task_work_result ))
  fi

  [ "$DEBUG" = "1" ] && debug_info

  if [ "$sum" = "$STANDARD_SUM" ] && [ "$product" = "$STANDARD_PRODUCT" ]; then
    echo "1"
  elif [ "$product" = "0" ]; then
    echo "0"
  else
    echo "-1"
  fi
}

get_cmd() {
  # TODO: sed -e 's/\\"/"/g' might be unnecessary.
  cmd=$(jq -r ".\"${SERVICE}\".${TIMEFRAME}.${STRATEGY}.$1" "$STRATEGY_FILE" | sed -e 's/\\"/"/g')

  # e.g.
  #   BEFORE: INHERIT .youtube.qtg0200.scraping_by.todo_personal
  #   AFTER:  todo-accomplished --repo 'noraworld/reserved-diary' --past 0 --retry 1 --checked 24 --unchecked 0 $force $cache_only
  while [ "$(echo "$cmd" | grep -cE "$INHERIT_KEYWORD_REGEXP")" -eq 1 ]; do
    cmd=$(jq -r "$(echo "$cmd" | sed -e "s/$INHERIT_KEYWORD_REGEXP//")" "$STRATEGY_FILE")
  done

  echo "$cmd"
}

prepare() {
  parse "$@"
  eval "set -- $REST"
}

list_info() {
  if [ "$LIST_TIMEFRAMES" = "1" ]; then
    for tf in $TIMEFRAME_RELATIVE_LIST $TIMEFRAME_LIST; do
      printf '%s\n' "$tf"
    done
    exit 0
  elif [ "$LIST_SERVICES" = "1" ]; then
    jq -r 'keys[]' "$STRATEGY_FILE"
    exit 0
  fi
}

debug_info() {
  observer=$(get_observer "$SERVICE")
  # https://chatgpt.com/share/68cff0fa-0234-8004-bcce-cfa2797ce950
  # https://gemini.google.com/app/7dacfcda212451f3
  daemon_status=$(systemctl is-active --user observe-"$observer"-conf)
  case "$daemon_status" in
    "active")
      daemon_status_color="$NG_COLOR"
      ;;
    "reloading")
      daemon_status_color="$DRY_COLOR"
      ;;
    "inactive")
      daemon_status_color="$OK_COLOR"
      ;;
    "failed")
      daemon_status_color="$NG_COLOR"
      ;;
    "activating")
      daemon_status_color="$DRY_COLOR"
      ;;
    "deactivating")
      daemon_status_color="$DRY_COLOR"
      ;;
    *)
      daemon_status_color="$NG_COLOR"
      ;;
  esac

  if [ "$todo_personal_result" = "$STANDARD_TODO_PERSONAL" ]; then
    todo_personal_result_color="$OK_COLOR"
  elif [ "$todo_personal_result" = "$DRY_RUN_RESULT" ]; then
    todo_personal_result_color="$DRY_COLOR"
  else
    todo_personal_result_color="$NG_COLOR"
  fi

  if [ "$task_personal_result" = "$STANDARD_TASK_PERSONAL" ]; then
    task_personal_result_color="$OK_COLOR"
  elif [ "$task_personal_result" = "$DRY_RUN_RESULT" ]; then
    task_personal_result_color="$DRY_COLOR"
  else
    task_personal_result_color="$NG_COLOR"
  fi

  if [ "$tick_personal_result" = "$STANDARD_TICK_PERSONAL" ]; then
    tick_personal_result_color="$OK_COLOR"
  elif [ "$tick_personal_result" = "$DRY_RUN_RESULT" ]; then
    tick_personal_result_color="$DRY_COLOR"
  else
    tick_personal_result_color="$NG_COLOR"
  fi

  if [ "$todo_work_result" = "$STANDARD_TODO_WORK" ]; then
    todo_work_result_color="$OK_COLOR"
  elif [ "$todo_work_result" = "$DRY_RUN_RESULT" ]; then
    todo_work_result_color="$DRY_COLOR"
  else
    todo_work_result_color="$NG_COLOR"
  fi

  if [ "$task_work_result" = "$STANDARD_TASK_WORK" ]; then
    task_work_result_color="$OK_COLOR"
  elif [ "$task_work_result" = "$DRY_RUN_RESULT" ]; then
    task_work_result_color="$DRY_COLOR"
  else
    task_work_result_color="$NG_COLOR"
  fi

  if [ "$sum" = "$STANDARD_SUM" ]; then
    sum_color="$OK_COLOR"
  elif [ "$sum" = "$DRY_RUN_RESULT" ]; then
    sum_color="$DRY_COLOR"
  else
    sum_color="$NG_COLOR"
  fi

  if [ "$product" = "$STANDARD_PRODUCT" ]; then
    product_color="$OK_COLOR"
  elif [ "$product" = "$DRY_RUN_RESULT" ]; then
    product_color="$DRY_COLOR"
  else
    product_color="$NG_COLOR"
  fi

  printf  "DEBUG: TIMEFRAME:             %s\n"                                               "$TIMEFRAME"                                        >&2
  printf  "DEBUG: daemon:                $daemon_status_color%s$RESET_COLOR\n"               "     $daemon_status"                               >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: todo_personal_cmd:     %s\n"                                               "$todo_personal_cmd"                                >&2
  printf  "DEBUG: todo_personal_result:  $todo_personal_result_color%6s (%s)$RESET_COLOR\n"  "$todo_personal_result"  "$STANDARD_TODO_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: task_personal_cmd:     %s\n"                                               "$task_personal_cmd"                                >&2
  printf  "DEBUG: task_personal_result:  $task_personal_result_color%6s (%s)$RESET_COLOR\n"  "$task_personal_result"  "$STANDARD_TASK_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: tick_personal_cmd:     %s\n"                                               "$tick_personal_cmd"                                >&2
  printf  "DEBUG: tick_personal_result:  $tick_personal_result_color%6s (%s)$RESET_COLOR\n"  "$tick_personal_result"  "$STANDARD_TICK_PERSONAL"  >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: todo_work_cmd:         %s\n"                                               "$todo_work_cmd"                                    >&2
  printf  "DEBUG: todo_work_result:      $todo_work_result_color%6s (%s)$RESET_COLOR\n"      "$todo_work_result"      "$STANDARD_TODO_WORK"      >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: task_work_cmd:         %s\n"                                               "$task_work_cmd"                                    >&2
  printf  "DEBUG: task_work_result:      $task_work_result_color%6s (%s)$RESET_COLOR\n"      "$task_work_result"      "$STANDARD_TASK_WORK"      >&2
  printf  "\n"                                                                                                                                   >&2
  printf  "DEBUG: sum:                   $sum_color%6s (%s)$RESET_COLOR\n"                   "$sum"                   "$STANDARD_SUM"            >&2
  printf  "DEBUG: product:               $product_color%6s (%s)$RESET_COLOR\n"               "$product"               "$STANDARD_PRODUCT"        >&2
  printf  "\n"                                                                                                                                   >&2
}

convert_timeframe_relative() {
  original_timeframe="$TIMEFRAME"

  should_convert_tf=false
  for tf in $TIMEFRAME_RELATIVE_LIST; do
    if [ "$TIMEFRAME" = "$tf" ]; then
      should_convert_tf=true
      break
    fi
  done

  # https://chatgpt.com/share/68b191e2-4504-8004-a34e-e68c717ca1f5
  if [ "$should_convert_tf" = "true" ]; then
    now_hour=$(date +%H | sed 's/^0*//')
    [ "$now_hour" = "" ] && now_hour=0

    i=1
    for boundary in $TIMEFRAME_BOUNDARIES; do
      if [ "$now_hour" -lt "$boundary" ]; then
        i=$((i - 1))
        [ "$i" -eq 0 ] && i=$(echo "$TIMEFRAME_LIST" | awk '{ print NF }')

        if [ "$TIMEFRAME" = "prev" ]; then
          i=$((i - 1))
          [ "$i" -eq 0 ] && i=$(echo "$TIMEFRAME_LIST" | awk '{ print NF }')
        elif [ "$TIMEFRAME" = "next" ]; then
          i=$((i + 1))
          [ "$i" -gt "$(echo "$TIMEFRAME_LIST" | awk '{ print NF }')" ] && i=1
        fi

        TIMEFRAME="$(echo "$TIMEFRAME_LIST" | awk "{ print \$$i }")"
        break
      fi

      i=$((i + 1))
    done

    # 23 (11 p.m.) doesn't match the above logic.
    if [ "$TIMEFRAME" = "$original_timeframe" ]; then
      case "$TIMEFRAME" in
        "prev")
          i=$(echo "$TIMEFRAME_LIST" | awk '{ print NF - 1 }')
          ;;
        "now")
          i=$(echo "$TIMEFRAME_LIST" | awk '{ print NF }')
          ;;
        "next")
          i=1
          ;;
      esac

      TIMEFRAME="$(echo "$TIMEFRAME_LIST" | awk "{ print \$$i }")"
    fi
  fi
}

get_observer() {
  if [ "$1" = "upstream" ]; then
    # any upstream name will do as long as it's active
    echo "adguard-upstream"
  else
    echo "$1"
  fi
}

validate() {
  valid_tf=false

  for tf in $TIMEFRAME_LIST; do
    if [ "$TIMEFRAME" = "$tf" ]; then
      valid_tf=true
      break
    fi
  done

  if [ "$valid_tf" != "true" ]; then
    echo "Error: Invalid TIMEFRAME: $TIMEFRAME" >&2
    exit 1
  fi
}

# @getoptions
parser_definition() {
  setup REST help:usage -- "Usage: quotarget [options]... [arguments]..." ''
  msg -- 'Options:'
  flag  DEBUG              --debug           -- "show debug messages"
  flag  DRY_RUN            --dry-run         -- "check only the standard (used when preventing it from calling the APIs)"
  flag  FORCE              --force           -- "get content from APIs even if cache exists"
  flag  LIST_TIMEFRAMES    --list-timeframes -- "get list of timeframes"
  flag  LIST_SERVICES      --list-services   -- "get list of services"
  flag  CACHE_ONLY         --cache-only      -- "use cache even if cache is stale (ignore check interval)"
  param SERVICE            --service         -- "youtube, vod, ..."
  param TIMEFRAME          --timeframe       -- "timeframe"
  disp  :usage          -h --help
  disp  VERSION            --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
DRY_RUN=''
FORCE=''
LIST_TIMEFRAMES=''
LIST_SERVICES=''
CACHE_ONLY=''
SERVICE=''
TIMEFRAME=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '--dry-run')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DRY_RUN="$OPTARG"
        ;;
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--list-timeframes')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        LIST_TIMEFRAMES="$OPTARG"
        ;;
      '--list-services')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        LIST_SERVICES="$OPTARG"
        ;;
      '--cache-only')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        CACHE_ONLY="$OPTARG"
        ;;
      '--service')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        SERVICE="$OPTARG"
        shift ;;
      '--timeframe')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TIMEFRAME="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: quotarget [options]... [arguments]...

Options:
      --debug                 show debug messages
      --dry-run               check only the standard (used when preventing it from calling the APIs)
      --force                 get content from APIs even if cache exists
      --list-timeframes       get list of timeframes
      --list-services         get list of services
      --cache-only            use cache even if cache is stale (ignore check interval)
      --service SERVICE       youtube, vod, ...
      --timeframe TIMEFRAME   timeframe
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
