#!/bin/sh

# shellcheck disable=SC2004

# https://chat.openai.com/share/a37c2f7c-6ed6-4373-8cfb-5bc2d436e20e
# https://chat.openai.com/share/77d93a57-a6b4-4c52-a6ad-03726f116ddc
# https://chat.openai.com/share/8392f873-40ad-4a47-922c-26892a098571
# https://chat.openai.com/share/daa739ff-7e80-4f55-83b3-e3bea92daeb1
# https://chat.openai.com/share/902f66af-1bd1-4be8-9c0e-2cb363ccb60d
# https://chat.openai.com/share/edeeb1b2-6df9-4c33-ac6e-84dfc27e7f8f

GARLIC_STORAGE="/home/ubuntu/.tmp/garlic.dat"
GET_UP_AFTER="8"
GET_UP_BEFORE="11"

main() {
  parse "$@"
  eval "set -- $REST"

  operation="$1"

  case "$operation" in
    "prep")
      prep "$@"
      ;;
    "savor")
      savor "$@"
      ;;
    "wipe")
      wipe "$@"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

prep() {
  skipped="false"

  if [ -f "$GARLIC_STORAGE" ] && [ "$FORCE" != "1" ]; then
    printf "A piece of garlic has already been prepared. Would you like to prepare it again? [y/N]: "
    exec < /dev/tty
    read -r confirm

    if [ "$confirm" = "y" ] || [ "$confirm" = "yes" ]; then
      rm -f "$GARLIC_STORAGE"
      touch "$GARLIC_STORAGE"
    else
      skipped="true"
      echo "OK, it won't be created." >&2
    fi
  else
    [ -f "$GARLIC_STORAGE" ] && rm -f "$GARLIC_STORAGE"
    touch "$GARLIC_STORAGE"
  fi

  if [ -f "$GARLIC_STORAGE" ] && [ "$skipped" = "false" ]; then
    echo "$GARLIC_STORAGE created"
  elif ! [ -f "$GARLIC_STORAGE" ] && [ "$skipped" = "false" ]; then
    echo "error: failed to create file $GARLIC_STORAGE for some reason" >&2
  fi
}

savor() {
  if ! [ -f "$GARLIC_STORAGE" ]; then
    [ "$VERBOSE" = "1" ] && echo "$GARLIC_STORAGE does not exist"
    echo "-1"
  else
    if [ "$VERBOSE" = "1" ]; then
      stat "$GARLIC_STORAGE"
      printf "Result: "
    fi

    get_up_at=$(
      stat "$GARLIC_STORAGE"  |
      grep "Birth"            |
      sed -r "s/\sBirth:\s//" |
      awk '{ print $2 }'      |
      awk -F: '{ print $1 }'
    )

    if [ "$get_up_at" -ge "$GET_UP_AFTER" ] && [ "$get_up_at" -le "$GET_UP_BEFORE" ]; then
      echo "1"
    else
      echo "-1"
    fi
  fi
}

wipe() {
  skipped="false"

  if ! [ -f "$GARLIC_STORAGE" ]; then
    echo "A piece of garlic has already been dumped." >&2
    skipped="true"
  elif [ -f "$GARLIC_STORAGE" ] && [ "$FORCE" != "1" ]; then
    printf "Would you like to dump a piece of garlic? [y/N]: "
    exec < /dev/tty
    read -r confirm

    if [ "$confirm" = "y" ] || [ "$confirm" = "yes" ]; then
      rm -f "$GARLIC_STORAGE"
    else
      skipped="true"
      echo "OK, it won't be deleted." >&2
    fi
  else
    rm -f "$GARLIC_STORAGE"
  fi

  if ! [ -f "$GARLIC_STORAGE" ] && [ "$skipped" = "false" ]; then
    echo "$GARLIC_STORAGE deleted"
  elif [ -f "$GARLIC_STORAGE" ] && [ "$skipped" = "false" ]; then
    echo "error: failed to delete file $GARLIC_STORAGE for some reason" >&2
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: garnish [options]... [arguments]..." ''
  msg -- 'Argument:'
  msg -- '  prep                        create a garnish file'
  msg -- '  savor                       check if a garnish file exists'
  msg -- '  wipe                        delete a garnish file'
  msg -- ''
  msg -- 'Options:'
  flag    FORCE      --force   -- "perform the action without confirmation"
  flag    VERBOSE    --verbose -- "show detailed information for savor"
  disp    :usage  -h --help
  disp    VERSION    --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
FORCE=''
VERBOSE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--verbose')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VERBOSE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: garnish [options]... [arguments]...

Argument:
  prep                        create a garnish file
  savor                       check if a garnish file exists
  wipe                        delete a garnish file

Options:
      --force                 perform the action without confirmation
      --verbose               show detailed information for savor
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
