#!/bin/sh



###
### Returned value:
###   File | Output: Reason
###   ---- | ----- : ------
###      1 |      1: No illegal activity was found.
###      0 | (none): Some commands (maybe ghc commands) failed, so did nothing even if there is illegal activity.
###     -1 |     -1: Illegal activity was found and the body was updated.
###     -2 | (none): Illegal timestamp was detected from the last update.
###



# This is important because the body becomes empty when the ghc command fails.
set -e

export GHC_FROM="$(basename "$0") $*"

CHECK_INTERVAL="3600"
NEW_DAY_OFFSET="8 hours ago"

main() {
  prepare "$@"
  police "$@"

  if [ "$(updatable)" -lt 0 ]; then
    cat "$RESULT_FILE"
    exit "200"
  else
    echo "0" > "$RESULT_FILE"
  fi

  validate "$@"

  body=$(todo-cache --repo "$MAIN_REPO" --date "$(date -d "$NEW_DAY_OFFSET" +%F)" "$force" "$cache_only")

# DO NOT INDENT THESE LINES!
while IFS= read -r line; do
  true_body="$true_body$(build_true_tasklist "$line")\n"
done <<EOF
$body
EOF

  if [ "$body" != "$(echo "$true_body" | sed '${/^$/d}')" ]; then
    # Update the body because it was illegal!
    number=$(ghc issue list --repo "$MAIN_REPO" --limit 1 | awk '{ print $1 }')
    ghc issue edit --repo "$MAIN_REPO" "$number" --body "$(echo "$true_body" | sed '${/^$/d}')" > /dev/null 2>&1
    true_body_result="-1"
  else
    true_body_result="1"
  fi

  template_body=$(ghc api "repos/$MAIN_REPO/contents/.github/ISSUE_TEMPLATE/general.md" --jq .content | base64 --decode)

# DO NOT INDENT THESE LINES!
mandatory_tasks_result="1"
while IFS= read -r line; do
  if [ "$(detect_mandatory_tasks "$line")" = "-1" ]; then
    mandatory_tasks_result="-1"
    break
  fi
done <<EOF
$template_body
EOF

  if [ "$true_body_result" = "1" ] && [ "$mandatory_tasks_result" = "1" ]; then
    echo "1" > "$RESULT_FILE"
    echo "1"
  elif [ "$true_body_result" = "-1" ] || [ "$mandatory_tasks_result" = "-1" ]; then
    echo "-1" > "$RESULT_FILE"
    echo "-1"
  else
    echo "0" > "$RESULT_FILE"
    echo "0"
  fi
}

# I wonder if there is a better way to suppress the number of calls of the APIs ðŸ¤”
build_true_tasklist() {
  # Check if a target diary templates has a comment when the checkbox is checked.
  # Mark an illegal flag if the list of comments is empty.
  if { [ "$(
    echo "$1" |
    grep -cE "\*\s*\[x\].*\[.*\]\(https\:\/\/github\.com\/$(echo $TEMPLATE_REPO | sed -r "s|/|\\\/|g")\/issues\/[0-9]*\)"
  )" -ne 0 ] && [ "$(
    ghc issue view \
      --json comments \
      --jq .comments.[].body \
      "$(echo "$1" | grep -oP '\(https?://[^\)]*\)' | sed 's/[()]//g')" ||
    echo "something"
  )" = "" ]; }; then
    illegal=true
  fi

  # Check if a target to-do issue is closed when the checkbox is checked.
  # Mark an illegal flag is the issue is open.
  if { [ "$(
    echo "$1" |
    grep -cE "\*\s*\[x\]\s*\[.*\]\(https\:\/\/github\.com\/$(
      echo $TODO_REPO | sed -r "s|/|\\\/|g" | sed -E 's/,/|/g'
    )\/issues\/[0-9]*\)"
  )" -ne 0 ] && [ "$(
    ghc issue view \
      --json state \
      --jq .state \
      "$(echo "$1" | grep -oP '\(https?://[^\)]*\)' | sed 's/[()]//g')"
  )" = "OPEN" ]; }; then
    illegal=true
  fi

  # Uncheck the checkbox if it's illegal.
  # Otherwise do nothing (return the same value.)
  if [ "$illegal" = "true" ]; then
    echo "$1" | sed -r "s/^\*\s*\[x\]/\* \[ \]/g"
  else
    echo "$1"
  fi
}

detect_mandatory_tasks() {
  # Return "-1" if mandatory tasks' checkbox doesn't exist.
  # It is the responsibility of build_true_tasklist() to determine whether the URL is valid.
  #
  #   OK:
  #     * [x] ðŸŒ± [çž‘æƒ³](https://github.com/noraworld/diary-templates/issues/8083)
  #     * [ ] ðŸŒ± [çž‘æƒ³](https://github.com/noraworld/diary-templates/issues/8083)
  #
  #   NG:
  #     * ðŸŒ± [çž‘æƒ³](https://github.com/noraworld/diary-templates/issues/8083)
  #     (doesn't exist on the checklist)
  #
  if [ "$(echo "$1" | grep -cE "\*\s*\[\s\]")" -gt 0 ]; then
    diary_template_title=$(echo "$1" | sed -E 's/^\* \[[ x]?\]( [^ ]+)? //')

    if [ "$(
      echo "$body" |
      grep -cE "\*\s*\[[ x]\].*\[$diary_template_title\]\(https\:\/\/github\.com\/$(
        echo $TEMPLATE_REPO |
        sed -r "s|/|\\\/|g"
      )\/issues\/[0-9]*\)"
    )" -eq 0 ]; then
      echo "-1"
    fi
  fi
}

prepare() {
  parse "$@"
  eval "set -- $REST"

  if [ "$FORCE" = 1 ]; then
    CHECK_INTERVAL="0"
    force="--force"
  else
    force=""
  fi

  if [ "$CACHE_ONLY" = "1" ]; then
    cache_only="--cache-only"
  else
    cache_only=""
  fi

  CHECK_FILE="/home/ubuntu/workspace/log/pi/tmp/illegal_check_detector_$(echo "$MAIN_REPO" | cut -d '/' -f2 | tr '-' '_')_last_update"
  RESULT_FILE="/home/ubuntu/workspace/log/pi/tmp/illegal_check_detector_$(echo "$MAIN_REPO" | cut -d '/' -f2 | tr '-' '_')_last_result"
  [ -e "$CHECK_FILE"  ] || date +%s  > "$CHECK_FILE"
  [ -e "$RESULT_FILE" ] || echo "-1" > "$RESULT_FILE"
}

police() {
  if [ "$(echo $(( $(date +%s) - $(cat "$CHECK_FILE") )) )" -lt 0 ]; then
    echo "An illegal timestamp was detected from the last update." >&2
    echo "-2" > "$RESULT_FILE"
    exit "2"
  fi
}

updatable() {
  if [ "$CACHE_ONLY" = "1" ]; then
    [ "$VERBOSE" = "1" ] && echo "It did nothing because --cache-only is passed." >&2
    echo "-1"
  elif
    [ "$(cat "$RESULT_FILE")" -eq 0 ] ||
    [ "$(echo $(( $(date +%s) - $(cat "$CHECK_FILE") )) )" -gt "$CHECK_INTERVAL" ]
  then
    [ "$VERBOSE" = "1" ] && echo "It has not taken $CHECK_INTERVAL seconds since the last update." >&2
    date +%s > "$CHECK_FILE"
    echo "1"
  else
    echo "-1"
  fi
}

validate() {
  if [ "$(echo "$MAIN_REPO" | grep -cE ".*/.*")" -ne 1 ]; then
    echo "This is not a repository (MAIN_REPO)" >&2
    exit
  fi

  if [ "$STRICT" = "1" ] && ! ghc repo view "$MAIN_REPO" > /dev/null 2>&1; then
    echo "No repository found (MAIN_REPO)" >&2
    exit
  fi

  if [ "$(echo "$TEMPLATE_REPO" | grep -cE ".*/.*")" -ne 1 ]; then
    echo "This is not a repository (TEMPLATE_REPO)" >&2
    exit
  fi

  if [ "$STRICT" = "1" ] && ! ghc repo view "$TEMPLATE_REPO" > /dev/null 2>&1; then
    echo "No repository found (TEMPLATE_REPO)" >&2
    exit
  fi

  if [ "$(echo "$TODO_REPO" | grep -cE ".*/.*")" -ne 1 ]; then
    echo "This is not a repository (TODO_REPO)" >&2
    exit
  fi

  if [ "$STRICT" = "1" ] && ! ghc repo view "$TODO_REPO" > /dev/null 2>&1; then
    echo "No repository found (TODO_REPO)" >&2
    exit
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: illegal-check-detector [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    FORCE            --force         -- "ignore check interval and get content from APIs even if cache exists"
  flag    STRICT           --strict        -- "check repo existence strictly"
  param   MAIN_REPO        --main-repo     -- "main repo"
  flag    CACHE_ONLY       --cache-only    -- "use cache even if cache is stale (ignore check interval)"
  param   TEMPLATE_REPO    --template-repo -- "template repo"
  param   TODO_REPO        --todo-repo     -- "todo repo"
  flag    VERBOSE          --verbose       -- "verbose output for debug"
  disp    :usage        -h --help
  disp    VERSION          --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
FORCE=''
STRICT=''
MAIN_REPO=''
CACHE_ONLY=''
TEMPLATE_REPO=''
TODO_REPO=''
VERBOSE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--strict')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        STRICT="$OPTARG"
        ;;
      '--main-repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        MAIN_REPO="$OPTARG"
        shift ;;
      '--cache-only')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        CACHE_ONLY="$OPTARG"
        ;;
      '--template-repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TEMPLATE_REPO="$OPTARG"
        shift ;;
      '--todo-repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TODO_REPO="$OPTARG"
        shift ;;
      '--verbose')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VERBOSE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: illegal-check-detector [options]... [arguments]...

Options:
      --force                 ignore check interval and get content from APIs even if cache exists
      --strict                check repo existence strictly
      --main-repo MAIN_REPO   main repo
      --cache-only            use cache even if cache is stale (ignore check interval)
      --template-repo TEMPLATE_REPO
                              template repo
      --todo-repo TODO_REPO   todo repo
      --verbose               verbose output for debug
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
