#!/bin/sh
# shellcheck disable=SC2004

main() {
  authenticate
  set_env
  parse "$@"
  eval "set -- $REST"

  case "$1" in
    "start")
      if [ "$(systemctl --user is-active "$2")" != "active" ]; then
        systemctl --user "$1" "$2"

        if [ "$SAFE" != 1 ]; then
          punish "$@"
        fi
      fi
      ;;
    "stop")
      if [ "$(systemctl --user is-active "$2")" = "active" ]; then
        systemctl --user "$1" "$2"
      fi
      ;;
    *)
      systemctl --user "$1" "$2"
      ;;
  esac
}

punish() {
  # choose either one of them
  #
  # sudo shutdown now
  # sudo systemctl stop ssh

  # for debug
  #
  echo "manual disablement detected (args: \"$*\", date: \"$(date)\")" >> /home/ubuntu/.log/cron-daemonctl.log
}

authenticate() {
  IS_CRON_SCRIPT=$(dirname "$(realpath "$0")")/../../bin/lib/is-cron

  if [ "$(sh -c "$IS_CRON_SCRIPT")" = false ]; then
    echo "Fatal: This operation must be executed by cron, or this script does not take enough effect" >&2
    exit 2
  fi
}

set_env() {
  # This is necessary when manipulating systemctl with cron
  #   https://superuser.com/questions/1561076/systemctl-use-failed-to-connect-to-bus-no-such-file-or-directory-debian-9
  XDG_RUNTIME_DIR=/run/user/$(id -u)
  export XDG_RUNTIME_DIR
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: scheduler [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    SAFE       --safe    -- "not getting punished"
  disp    :usage  -h --help    -- "show help message and exit"
  disp    VERSION    --version -- "show current version"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
SAFE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--safe')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SAFE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: scheduler [options]... [arguments]...

Options:
      --safe                  not getting punished
  -h, --help                  show help message and exit
      --version               show current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
