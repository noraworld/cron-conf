#!/bin/sh
# shellcheck disable=SC2004

XDG_RUNTIME_DIR="/run/user/$(id -u)"
PULSE_RUNTIME_PATH="/run/user/$(id -u)/pulse/"
PRIV_TOGGLE_DIR="/etc/dnsmasq.priv/toggle"

SECOND_ALARM_INTERVAL="30 min"   # The second alarm goes off the time given here after the first one does.
THIRD_ALARM_INTERVAL="41 min"    # The third alarm goes off the time given here after the FIRST one does.
MINIMUM_ALARM_DURATION="10 min"  # The third alarm goes off for at least the time given here.
ALARM_DISABLED_DURATION="60 min" # The SSH connection is lost for the time given here when the alarm is disabled.

UPTIME_THRESHOLD="5"

export GHC_FROM="$(basename "$0") $*"

main() {
  export XDG_RUNTIME_DIR
  export PULSE_RUNTIME_PATH

  service="$1"
  operation="$2"

  parse "$@"
  eval "set -- $REST"

  if [ "$SAFE" = 1 ]; then
    safe="--safe"
  else
    # shellcheck disable=SC2034
    safe=""
  fi

  # COMMENT OUT these lines (put "#" at the beginning of these lines if they don't exist) if you want to ENABLE morning
  # bonus time. When enabling them, "scheduler [service_name] deny --vampire" is virtually the same as
  # "scheduler [service_name] allow". In other words, ACTIVATE these lines (remove "#" at the beginning of these lines
  # if they exist) if you want to DISABLE morning bonus time.
  # [ "$MORNING" = "1" ] && MORNING="-1"
  # [ "$VAMPIRE" = "1" ] && VAMPIRE="-1"

  # COMMENT OUT this line (put "#" at the beginning of this line if it doesn't exist) if you want to ENABLE the
  # kryptonite mode. When enabling it, the restriction is exempted even after midnight. In other words, ACTIVATE this
  # line (remove "#" at the beginning of this line if it exists) if you want to DISABLE the kryptonite mode.
  [ "$PURPLE_KRYPTONITE" = "1" ] && PURPLE_KRYPTONITE="-1"
  [ "$RED_KRYPTONITE"    = "1" ] && RED_KRYPTONITE="-1"
  [ "$YELLOW_KRYPTONITE" = "1" ] && YELLOW_KRYPTONITE="-1"

  case "$service" in
    "amazon")
      amazon
      ;;
    "chime")
      chime
      ;;
    "crimson")
      crimson
      ;;
    "deregulated-superman")
      deregulated_superman
      ;;
    "firewall")
      firewall
      ;;
    "focus")
      focus
      ;;
    "gaming")
      gaming
      ;;
    "github-editor")
      github_editor
      ;;
    "night")
      night
      ;;
    "maeve")
      maeve
      ;;
    "good")
      good
      ;;
    "morning")
      morning
      ;;
    "netflix")
      netflix
      ;;
    "observe")
      observe
      ;;
    "ometeotl")
      ometeotl
      ;;
    "periodic")
      periodic
      ;;
    "schedules-update-ready")
      schedules_update_ready "$@"
      ;;
    "snorlax")
      snorlax
      ;;
    "startup")
      startup
      ;;
    "superman")
      superman
      ;;
    "todo")
      todo
      ;;
    "todo-night")
      todo_night
      ;;
    "upstream")
      upstream
      ;;
    "vod")
      vod
      ;;
    "youtube")
      youtube
      ;;
    "youtube-alternative")
      youtube_alternative
      ;;
    "youtube-music")
      youtube_music
      ;;
    *)
      echo "error: no such service: \"$service\"" >&2
      exit 1
      ;;
  esac
}

amazon() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-amazon-conf "$safe"
        remove-dnsmasq-toggle-conf public amazon
        return
      fi

      cron-daemonctl start observe-amazon-conf "$safe"
      create-dnsmasq-toggle-conf public amazon
      # create-iptables-toggle-conf public 131_amazon
      ;;
    "allow")
      cron-daemonctl stop observe-amazon-conf "$safe"
      remove-dnsmasq-toggle-conf public amazon
      # remove-iptables-toggle-conf public 131_amazon
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

chime() {
  case "$operation" in
    "deny")
      create-dnsmasq-toggle-conf public chime
      ;;
    "allow")
      remove-dnsmasq-toggle-conf public chime
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

crimson() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-crimson-conf "$safe"
      remove-dnsmasq-toggle-conf private crimson
      ;;
    "allow")
      cron-daemonctl stop observe-crimson-conf "$safe"
      # create-dnsmasq-toggle-conf private crimson
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

good() {
  garnish wipe
}

morning() {
  # File health check
  # to revert network configuration files to prevent being locked out of the SSH connection.
  clean-repo perform                                                  \
    "/home/ubuntu/workspace/cron-conf"                                \
    "/home/ubuntu/workspace/dnsmasq-conf/dnsmasq"                     \
    "/home/ubuntu/workspace/envsman/raspberrypi/dnsmasq/dnsmasq.priv" \
    "/home/ubuntu/workspace/ufw-conf"                                 \
    "/home/ubuntu/workspace/netplan-conf"
  temp-eliminater

  # Fan control
  metronome set full

  # Alarm clock
  #
  #   Sound name:   The Other Day I Met a Bear
  #   Sound source: https://muryochakumero.com/%E7%9D%80%E3%83%A1%E3%83%AD/16646
  #   Inspired by:  Classroom of the Elite
  #
  #   Perform the following command to stop the sound.
  #
  #     juke stop all
  #
  if [ "$(marlin info WH-1000XM3 | grep -c "Connected: yes")" -ge 1 ]; then
    ## First
    juke play       \
      --volume=0.05 \
      /home/ubuntu/.pibox/the_other_day_i_met_a_bear.mp3

    ## Second
    echo "juke play                                       \
      --volume=0.25                                       \
      /home/ubuntu/.pibox/the_other_day_i_met_a_bear.mp3" |
      at now + "$SECOND_ALARM_INTERVAL"

    ## Third
    echo "juke play                                       \
      --volume=0.025                                      \
      --gradual=0.025                                     \
      --max=3.0                                           \
      --times=120                                         \
      /home/ubuntu/.pibox/the_other_day_i_met_a_bear.mp3" |
      at now + "$THIRD_ALARM_INTERVAL"
  fi
  #
  # Do not append anything between the alarm section and the SSH section.
  # The SSH section checks whether the alarm is playing,
  # and if you add something that takes time to proceed between them,
  # the alarm may stop before the confirmation.
  #
  # SSH
  if [ "$MORNING" = "1" ]; then
    if [ "$(ps aux | grep juke | grep -cv grep)" -ge 1 ]; then
      echo "/home/ubuntu/workspace/cron-conf/bin/lib/punish          \
        --from "$(echo "$(basename "$0")" "$*" | sed -r 's/\s$//g')" \
        --duration \""$MINIMUM_ALARM_DURATION"\""                    |
        at now + "$THIRD_ALARM_INTERVAL"
    else
      echo "/home/ubuntu/workspace/cron-conf/bin/lib/punish          \
        --from "$(echo "$(basename "$0")" "$*" | sed -r 's/\s$//g')" \
        --duration \""$ALARM_DISABLED_DURATION"\""                   |
        at now + "$THIRD_ALARM_INTERVAL"
    fi
  fi

  # Network
  # vpnctl disconnect --skipdns
}

deregulated_superman() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-deregulated-superman-conf "$safe"
        cron-daemonctl stop observe-deregulated-superman-allow-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-conf "$safe"
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-allow-conf "$safe"
      # it will take a few mintutes to finish these two process because the Dnsmasq daemon restarts twice
      remove-dnsmasq-toggle-conf private deregulated_superman_allow
      create-dnsmasq-toggle-conf private deregulated_superman
      # create-iptables-toggle-conf private 231_deregulated_superman
      ;;
    "allow")
      :
      cron-daemonctl stop observe-deregulated-superman-conf "$safe"
      cron-daemonctl stop observe-deregulated-superman-allow-conf "$safe"
      # remove-dnsmasq-toggle-conf private deregulated_superman
      # remove-iptables-toggle-conf private 231_deregulated_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

firewall() {
  # Observe a firewall blocking the DNS port
  #
  # How to check if it works fine:
  #
  #   Make sure the following command returns 0
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   Then execute the following command
  #     $ sudo iptables -A FORWARD -p udp -m udp --dport 53 -j ACCEPT
  #
  #   Perform the following command again and make sure it returns 1
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   If it works properly, the result of the above command should be reset to 0 when the observer is executed
  #
  case "$operation" in
    "deny")
      cron-daemonctl start observe-firewall "$safe"
      ;;
    "allow")
      # Do nothing if "schedules_update_ready" doesn't return "1" or "-1".
      if [ "$(schedules_update_ready)" -lt 0 ]; then
        # TODO:
        #   Please delete this note below after confirming the phenomenon doesn't happen.
        #
        # MEMO:
        #   Note that when the firewall observer stops once but the todo observer is still working,
        #   and if communication with GitHub fails, this is performed and results in getting punished.
        #   [firewall_memo]
        cron-daemonctl start observe-firewall --safe
      elif [ "$(schedules_update_ready)" -gt 0 ]; then
        cron-daemonctl stop observe-firewall "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

focus() {
  case "$operation" in
    "deny")
      # cron-daemonctl start observe-focus-conf "$safe"
      create-dnsmasq-toggle-conf private focus
      # create-iptables-toggle-conf private 232_focus
      ;;
    "allow")
      # cron-daemonctl stop observe-focus-conf "$safe"
      remove-dnsmasq-toggle-conf private focus
      # remove-iptables-toggle-conf private 232_focus
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

gaming() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-gaming-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-gaming-conf "$safe"
      create-dnsmasq-toggle-conf public gaming
      ;;
    "allow")
      cron-daemonctl stop observe-gaming-conf "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

github_editor() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-github-editor-conf "$safe"
      create-dnsmasq-toggle-conf public github_editor
      ;;
    "allow")
      cron-daemonctl stop observe-github-editor-conf "$safe"
      remove-dnsmasq-toggle-conf public github_editor
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

night() {
  cs
}

maeve() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-maeve-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-maeve-conf "$safe"
      create-dnsmasq-toggle-conf private maeve
      ;;
    "allow")
      cron-daemonctl stop observe-maeve-conf "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

netflix() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-netflix-conf "$safe"
        cron-daemonctl stop observe-netflix-allow-conf "$safe"
        return
      fi

      cron-daemonctl start observe-netflix-conf "$safe"
      cron-daemonctl start observe-netflix-allow-conf "$safe"

      # it will take a few mintutes to finish these two process because the Dnsmasq daemon restarts twice
      [ "$(force-vpn check)" -lt 0 ] && remove-dnsmasq-toggle-conf public netflix_allow
      [ "$(force-vpn check)" -lt 0 ] && create-dnsmasq-toggle-conf public netflix
      # create-iptables-toggle-conf public 132_netflix
      ;;
    "allow")
      cron-daemonctl stop observe-netflix-conf "$safe"
      cron-daemonctl stop observe-netflix-allow-conf "$safe"
      # create-dnsmasq-toggle-conf public netflix_allow
      # remove-dnsmasq-toggle-conf public netflix
      # remove-iptables-toggle-conf public 132_netflix
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

observe() {
  case "$operation" in
    "start")
      cron-daemonctl start observe-crontab "$safe"
      cron-daemonctl start observe-cron-conf "$safe"
      cron-daemonctl start observe-dnsmasq-conf "$safe"
      cron-daemonctl start observe-dnsmasq-priv-conf "$safe"
      cron-daemonctl start observe-dnsmasq-toggle "$safe"
      cron-daemonctl start observe-dnsmasq-priv-toggle "$safe"
      ;;
    "stop")
      # Do nothing if "schedules_update_ready" doesn't return "1" or "-1".
      if [ "$(schedules_update_ready)" -lt 0 ]; then
        # TODO: Please delete this note below after confirming the phenomenon doesn't happen.
        # Note that the same phenomenon could happen as [firewall_memo].
        cron-daemonctl start observe-crontab --safe
        cron-daemonctl start observe-cron-conf --safe
        cron-daemonctl start observe-dnsmasq-conf --safe
        cron-daemonctl start observe-dnsmasq-priv-conf --safe
        cron-daemonctl start observe-dnsmasq-toggle --safe
        cron-daemonctl start observe-dnsmasq-priv-toggle --safe
      elif [ "$(schedules_update_ready)" -gt 0 ]; then
        cron-daemonctl stop observe-crontab "$safe"
        cron-daemonctl stop observe-cron-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-toggle "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-toggle "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

ometeotl() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-ometeotl-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-ometeotl-conf "$safe"
      create-dnsmasq-toggle-conf private ometeotl
      # create-iptables-toggle-conf private 234_ometeotl
      ;;
    "allow")
      :
      cron-daemonctl stop observe-ometeotl-conf "$safe"
      # remove-dnsmasq-toggle-conf private ometeotl
      # remove-iptables-toggle-conf private 234_ometeotl
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

periodic() {
  # Auto-update cron conf
  cron-apply perform

  # Observe IP address not getting lost
  ip-observer

  # Observe firewall not disabled
  auto-ufw-enabler

  # Observe the system clock not lagging
  clock-observer

  # Auto-update specific Git repositories
  #
  # While this script doesn't take effect while "git pull" is disabled by "observe-firewall",
  # it's important because settings that aren't changed automatically, especially the strict setting changes,
  # might not be changed for a while.
  #
  if [ "$(echo "$(awk '{print $1}' /proc/uptime)" / 60 | bc)" -gt "$UPTIME_THRESHOLD" ]; then
    auto-git-pull                            \
      "/home/ubuntu/workspace/cron-conf"     \
      "/home/ubuntu/workspace/dnsmasq-conf"  \
      "/home/ubuntu/workspace/envsman"       \
      "/home/ubuntu/workspace/systemd-units" &
  fi

  # Notify each time you achieve your daily digital detox
  digital-detox-notifier

  # It won't work if USB receivers aren't recognized.
  # And to make things worse, that happens frequently.
  #
  # Auto-connect the devices paired with Bluetooth (only the first successful connection after the Bluetooth daemon starts)
  # if [ -e "/home/ubuntu/.tmp/marlin_autoconnect" ]; then
  #   if [ "$(marlin info all --only iPhone,Mac | grep -c "Connected: no")" -ne 0 ]; then
  #     marlin autoconnect all --retry 2 --only iPhone,Mac
  #   else
  #     [ -e "/home/ubuntu/.tmp/marlin_autoconnect" ] && rm "/home/ubuntu/.tmp/marlin_autoconnect"
  #   fi
  # fi
}

snorlax() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-snorlax-conf "$safe"
      create-dnsmasq-toggle-conf public snorlax
      ;;
    "allow")
      cron-daemonctl stop observe-snorlax-conf "$safe"
      remove-dnsmasq-toggle-conf public snorlax
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

startup() {
  log-reboot
  clock-observer
  metronome set full
  search-stoppable-observer-daemons --skip --delay 30
  # marlin autoconnect all --retry 2 --only iPhone,Mac # --log /home/ubuntu/.log/bluetooth_autoconnect.log
}

superman() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-superman-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-superman-conf "$safe"
      create-dnsmasq-toggle-conf private superman
      # create-iptables-toggle-conf private 233_superman
      ;;
    "allow")
      cron-daemonctl stop observe-superman-conf "$safe"
      # remove-dnsmasq-toggle-conf private superman
      # remove-iptables-toggle-conf private 233_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

todo() {
  case "$operation" in
    "start")
      if [ "$MORNING" = "1" ]; then
        cron-daemonctl stop observe-dnsmasq-todo-list "$safe"
        return
      fi

      cron-daemonctl start observe-dnsmasq-todo-list "$safe"
      ;;
    "stop")
      cron-daemonctl stop observe-dnsmasq-todo-list "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

todo_night() {
  case "$operation" in
    "start")
      if [ "$MORNING" = "1" ]; then
        cron-daemonctl stop observe-dnsmasq-todo-list-night "$safe"
        return
      fi

      cron-daemonctl start observe-dnsmasq-todo-list-night "$safe"
      ;;
    "stop")
      cron-daemonctl stop observe-dnsmasq-todo-list-night "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

upstream() {
  # "cloudflare_upstream" or "superman_upstream"
  PRIORITY="superman_upstream"
  NON_PRIORITY="cloudflare_upstream"

  # Every upstream DNS file should be updated in succession without any interval.
  # When the previous file is deleted and the new file is not yet created, none of the upstream DNS files will be set, and the Internet connection will be blocked.
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-adguard-upstream-conf "$safe"
        cron-daemonctl stop observe-nordvpn-upstream-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-adguard-upstream-conf "$safe"
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-nordvpn-upstream-conf "$safe"
      remove-dnsmasq-toggle-conf private adguard_upstream --skip
      remove-dnsmasq-toggle-conf private nordvpn_upstream

      # Do nothing if either of them exists, even if the existing one is not prioritized,
      # because sometimes you may want to use the non-prioritized one.
      if [ -e "$PRIV_TOGGLE_DIR/$PRIORITY.conf" ] && [ -e "$PRIV_TOGGLE_DIR/$NON_PRIORITY.conf" ]; then
        remove-dnsmasq-toggle-conf private "$NON_PRIORITY"
      elif ! [ -e "$PRIV_TOGGLE_DIR/$PRIORITY.conf" ] && ! [ -e "$PRIV_TOGGLE_DIR/$NON_PRIORITY.conf" ]; then
        create-dnsmasq-toggle-conf private "$PRIORITY"
      fi
      ;;
    "allow")
      cron-daemonctl stop observe-adguard-upstream-conf "$safe"
      cron-daemonctl stop observe-nordvpn-upstream-conf "$safe"
      # remove-dnsmasq-toggle-conf private cloudflare_upstream --skip
      # remove-dnsmasq-toggle-conf private nordvpn_upstream    --skip
      # remove-dnsmasq-toggle-conf private superman_upstream   --skip
      # create-dnsmasq-toggle-conf private adguard_upstream
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

vod() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-vod-conf "$safe"
        return
      fi

      cron-daemonctl start observe-vod-conf "$safe"
      create-dnsmasq-toggle-conf public vod
      # create-iptables-toggle-conf public 133_vod
      ;;
    "allow")
      cron-daemonctl stop observe-vod-conf "$safe"
      # remove-dnsmasq-toggle-conf public vod
      # remove-iptables-toggle-conf public 133_vod
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-youtube-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-conf "$safe"
      create-dnsmasq-toggle-conf public youtube
      # create-iptables-toggle-conf public 134_youtube
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-conf "$safe"
      # remove-dnsmasq-toggle-conf public youtube
      # remove-iptables-toggle-conf public 134_youtube
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_alternative() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-youtube-alternative-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-alternative-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_alternative
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-alternative-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_alternative
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_music() {
  case "$operation" in
    "deny")
      if { [ "$VAMPIRE" = "1" ] && [ "$(garnish savor)" -gt 0 ] && [ "$MORNING" != "-1" ]; } ||
      [ "$MORNING" = "1" ] || [ "$VAMPIRE" = "-1" ] ||
      [ "$PURPLE_KRYPTONITE" = "1" ] || [ "$RED_KRYPTONITE" = "1" ] || [ "$YELLOW_KRYPTONITE" = "1" ]; then
        cron-daemonctl stop observe-youtube-music-conf "$safe"
        return
      fi

      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-music-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_music
      # remove-iptables-toggle-conf public 135_youtube_music
      ;;
    "allow")
      :
      cron-daemonctl stop observe-youtube-music-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_music
      # create-iptables-toggle-conf public 135_youtube_music
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

#
# Returns false if the number of days given by TOOK_THRESHOLD has not elapsed since the cron file was updated on GitHub.
#
# Note that if the changes to a cron file are made on GitHub during the time when "scheduler firewall allow" and/or
# "scheduler observe stop" are performed, then the observers start working again without the "--safe" option,
# which means you get punished.
#
schedules_update_ready() {
  BASE_URL="https://api.github.com/repos"
  OWNER="noraworld"
  DAY_SECOND="86400"
  TOOK_THRESHOLD="0"

  if [ "$TOOK_THRESHOLD" -eq 0 ] && [ "$1" != "schedules-update-ready" ]; then
    echo "1"
    return
  fi

  local_cron_conf_updated_at=$(        git -C "/home/ubuntu/workspace/cron-conf"    --no-pager log -1 --format="%ct")
  local_dnsmasq_conf_updated_at=$(     git -C "/home/ubuntu/workspace/dnsmasq-conf" --no-pager log -1 --format="%ct")
  local_priv_dnsmasq_conf_updated_at=$(git -C "/home/ubuntu/workspace/envsman"      --no-pager log -1 --format="%ct")

  # https://docs.github.com/en/rest/commits/commits?apiVersion=2022-11-28
  cron_conf_updated_at=$(        ghc api "$BASE_URL/$OWNER/cron-conf/commits?per_page=1"    --jq ".[].commit.author.date")
  cron_conf_updated_at_succeeded="$?"
  dnsmasq_conf_updated_at=$(     ghc api "$BASE_URL/$OWNER/dnsmasq-conf/commits?per_page=1" --jq ".[].commit.author.date")
  dnsmasq_conf_updated_at_succeeded="$?"
  priv_dnsmasq_conf_updated_at=$(ghc api "$BASE_URL/$OWNER/envsman/commits?per_page=1"      --jq ".[].commit.author.date")
  priv_dnsmasq_conf_updated_at_succeeded="$?"

  if [ "$1" = "schedules-update-ready" ]; then
    if [ "$cron_conf_updated_at_succeeded"         -ne 0 ] ||
       [ "$dnsmasq_conf_updated_at_succeeded"      -ne 0 ] ||
       [ "$priv_dnsmasq_conf_updated_at_succeeded" -ne 0 ]; then

      # Failed to retrieve information.
      echo "0"
      exit "1"
    fi
  fi

  latest_timestamp=$(echo "$(date -d"$cron_conf_updated_at" +%s) $(date -d"$dnsmasq_conf_updated_at" +%s) $(date -d"$priv_dnsmasq_conf_updated_at" +%s)" | tr ' ' '\n' | sort -n | tail -n 1)
  updated_at=$(date --date "@$latest_timestamp")

  took_seconds=$(( $(date +%s) - latest_timestamp ))
  took_days=$(( took_seconds / DAY_SECOND ))

  if [ "$1" = "schedules-update-ready" ]; then
    HOUR_SECOND="3600"
    DAY_HOUR="24"
    MINUTE_SECOND="60"
    HOUR_MINUTE="60"

    if [ "$VERBOSE" = "1" ]; then
      echo "[DEBUG] updated at:  $(date -d"$updated_at")"
      echo "[DEBUG] now:         $(date)"
    fi

    echo "[DEBUG] took:        $(printf "%01s" "$took_days"                                                       ) days"    \
                              "$(printf "%02s" "$(( took_seconds / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                              "$(printf "%02s" "$(( took_seconds / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                              "$(printf "%02s" "$(( took_seconds % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"

    echo "[DEBUG] passes over: $(printf "%01s" "$TOOK_THRESHOLD") days" \
                              "$(printf "%02s" "0") hours"              \
                              "$(printf "%02s" "0") minutes"            \
                              "$(printf "%02s" "0") seconds"

    if [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
      if [ "$local_cron_conf_updated_at" = "$(date -d"$cron_conf_updated_at" +%s)" ] &&
         [ "$local_dnsmasq_conf_updated_at" = "$(date -d"$dnsmasq_conf_updated_at" +%s)" ] &&
         [ "$local_priv_dnsmasq_conf_updated_at" = "$(date -d"$priv_dnsmasq_conf_updated_at" +%s)" ]; then

        echo "[DEBUG] left:        up to date!"
      else
        echo "[DEBUG] left:        ready to update!"
      fi
    else
      echo "[DEBUG] left:        $(printf "%01s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / DAY_SECOND                                  ))") days"    \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"
    fi

    printf "[DEBUG] result:      "
  fi

  if [ "$updated_at" = "" ]; then
    # Failed to retrieve information.
    echo "0"
    return
  elif [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
    # Enough time has passed that you can update the cron.
    echo "1"
  else
    # Not enough time has passed to allow cron to be updated.
    echo "-1"
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: scheduler [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    PURPLE_KRYPTONITE    --purple-kryptonite -- "exempt the restriction even after midnight"
  flag    RED_KRYPTONITE       --red-kryptonite    -- "exempt the restriction even after midnight"
  flag    YELLOW_KRYPTONITE    --yellow-kryptonite -- "exempt the restriction even after midnight"
  flag    MORNING              --morning           -- "whether to exempt the restriction in the morning"
  flag    SAFE                 --safe              -- "not getting punished"
  flag    SOFT                 --soft              -- "deny resources without starting a daemon"
  flag    VAMPIRE              --vampire           -- "exempt the restriction if you beat your drowsiness in the morning"
  flag    VERBOSE              --verbose           -- "show detailed information"
  disp    :usage            -h --help              -- "show help message and exit"
  disp    VERSION              --version           -- "show current version"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
PURPLE_KRYPTONITE=''
RED_KRYPTONITE=''
YELLOW_KRYPTONITE=''
MORNING=''
SAFE=''
SOFT=''
VAMPIRE=''
VERBOSE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--purple-kryptonite')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        PURPLE_KRYPTONITE="$OPTARG"
        ;;
      '--red-kryptonite')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        RED_KRYPTONITE="$OPTARG"
        ;;
      '--yellow-kryptonite')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        YELLOW_KRYPTONITE="$OPTARG"
        ;;
      '--morning')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        MORNING="$OPTARG"
        ;;
      '--safe')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SAFE="$OPTARG"
        ;;
      '--soft')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SOFT="$OPTARG"
        ;;
      '--vampire')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VAMPIRE="$OPTARG"
        ;;
      '--verbose')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VERBOSE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: scheduler [options]... [arguments]...

Options:
      --purple-kryptonite     exempt the restriction even after midnight
      --red-kryptonite        exempt the restriction even after midnight
      --yellow-kryptonite     exempt the restriction even after midnight
      --morning               whether to exempt the restriction in the morning
      --safe                  not getting punished
      --soft                  deny resources without starting a daemon
      --vampire               exempt the restriction if you beat your drowsiness in the morning
      --verbose               show detailed information
  -h, --help                  show help message and exit
      --version               show current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
