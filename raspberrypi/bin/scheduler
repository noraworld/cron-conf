#!/bin/sh
# shellcheck disable=SC2004

XDG_RUNTIME_DIR="/run/user/$(id -u)"
PULSE_RUNTIME_PATH="/run/user/$(id -u)/pulse/"
PRIV_TOGGLE_DIR="/etc/dnsmasq.priv/toggle"

main() {
  export XDG_RUNTIME_DIR
  export PULSE_RUNTIME_PATH

  service="$1"
  operation="$2"

  parse "$@"
  eval "set -- $REST"

  if [ "$SAFE" = 1 ]; then
    safe="--safe"
  else
    # shellcheck disable=SC2034
    safe=""
  fi

  case "$service" in
    "amazon")
      amazon
      ;;
    "chime")
      chime
      ;;
    "deregulated-superman")
      deregulated_superman
      ;;
    "firewall")
      firewall
      ;;
    "focus")
      focus
      ;;
    "gaming")
      gaming
      ;;
    "github-editor")
      github_editor
      ;;
    "morning")
      morning
      ;;
    "netflix")
      netflix
      ;;
    "observe")
      observe
      ;;
    "ometeotl")
      ometeotl
      ;;
    "periodic")
      periodic
      ;;
    "schedules-update-ready")
      schedules_update_ready "$@"
      ;;
    "snorlax")
      snorlax
      ;;
    "startup")
      startup
      ;;
    "superman")
      superman
      ;;
    "todo")
      todo
      ;;
    "upstream")
      upstream
      ;;
    "vod")
      vod
      ;;
    "youtube")
      youtube
      ;;
    "youtube-alternative")
      youtube_alternative
      ;;
    "youtube-music")
      youtube_music
      ;;
    *)
      echo "error: no such service: \"$service\"" >&2
      exit 1
      ;;
  esac
}

amazon() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-amazon-conf "$safe"
      create-dnsmasq-toggle-conf public amazon
      # create-iptables-toggle-conf public 131_amazon
      ;;
    "allow")
      cron-daemonctl stop observe-amazon-conf "$safe"
      remove-dnsmasq-toggle-conf public amazon
      # remove-iptables-toggle-conf public 131_amazon
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

chime() {
  case "$operation" in
    "deny")
      create-dnsmasq-toggle-conf public chime
      ;;
    "allow")
      remove-dnsmasq-toggle-conf public chime
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

morning() {
  # Fan control
  metronome set full

  # Sound & Bluetooth
  sudo systemctl restart bluetooth
  touch "/home/ubuntu/.tmp/marlin_autoconnect"
  systemctl --user restart \
    pipewire.socket        \
    pipewire.service       \
    pipewire-pulse.socket  \
    pipewire-pulse.service \
    wireplumber.service

  # Alarm clock
  #
  #   Sound name:   The Other Day I Met a Bear
  #   Sound source: https://muryochakumero.com/%E7%9D%80%E3%83%A1%E3%83%AD/16646
  #   Inspired by:  Classroom of the Elite
  #
  #   Perform the following command to stop the sound.
  #
  #     juke stop all
  #
  juke play --volume=0.5 --infinite "/home/ubuntu/.pibox/the_other_day_i_met_a_bear.mp3"

  # Network
  vpnctl disconnect --skipdns
  sudo systemctl restart diary

  # File health check
  clean-repo perform                                                  \
    "/home/ubuntu/workspace/cron-conf"                                \
    "/home/ubuntu/workspace/dnsmasq-conf/dnsmasq"                     \
    "/home/ubuntu/workspace/envsman/raspberrypi/dnsmasq/dnsmasq.priv" \
    "/home/ubuntu/workspace/envsman/raspberrypi/etc/netplan"
}

deregulated_superman() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-conf "$safe"
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-allow-conf "$safe"
      # it will take a few mintutes to finish these two process because the Dnsmasq daemon restarts twice
      remove-dnsmasq-toggle-conf private deregulated_superman_allow
      create-dnsmasq-toggle-conf private deregulated_superman
      # create-iptables-toggle-conf private 231_deregulated_superman
      ;;
    "allow")
      :
      cron-daemonctl stop observe-deregulated-superman-conf "$safe"
      cron-daemonctl stop observe-deregulated-superman-allow-conf "$safe"
      # remove-dnsmasq-toggle-conf private deregulated_superman
      # remove-iptables-toggle-conf private 231_deregulated_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

firewall() {
  # Observe a firewall blocking the DNS port
  #
  # How to check if it works fine:
  #
  #   Make sure the following command returns 0
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   Then execute the following command
  #     $ sudo iptables -A FORWARD -p udp -m udp --dport 53 -j ACCEPT
  #
  #   Perform the following command again and make sure it returns 1
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   If it works properly, the result of the above command should be reset to 0 when the observer is executed
  #
  case "$operation" in
    "deny")
      cron-daemonctl start observe-firewall "$safe"
      ;;
    "allow")
      # Do nothing if "schedules_update_ready" doesn't return "1" or "-1".
      if [ "$(schedules_update_ready)" -lt 0 ]; then
        # TODO:
        #   Please delete this note below after confirming the phenomenon doesn't happen.
        #
        # MEMO:
        #   Note that when the firewall observer stops once but the todo observer is still working,
        #   and if communication with GitHub fails, this is performed and results in getting punished.
        #   [firewall_memo]
        cron-daemonctl start observe-firewall "$safe"
      elif [ "$(schedules_update_ready)" -gt 0 ]; then
        cron-daemonctl stop observe-firewall "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

focus() {
  case "$operation" in
    "deny")
      # cron-daemonctl start observe-focus-conf "$safe"
      create-dnsmasq-toggle-conf private focus
      # create-iptables-toggle-conf private 232_focus
      ;;
    "allow")
      # cron-daemonctl stop observe-focus-conf "$safe"
      remove-dnsmasq-toggle-conf private focus
      # remove-iptables-toggle-conf private 232_focus
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

gaming() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-gaming-conf "$safe"
      create-dnsmasq-toggle-conf public gaming
      ;;
    "allow")
      cron-daemonctl stop observe-gaming-conf "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

github_editor() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-github-editor-conf "$safe"
      create-dnsmasq-toggle-conf public github_editor
      ;;
    "allow")
      cron-daemonctl stop observe-github-editor-conf "$safe"
      remove-dnsmasq-toggle-conf public github_editor
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

netflix() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-netflix-conf "$safe"
      cron-daemonctl start observe-netflix-allow-conf "$safe"
      # it will take a few mintutes to finish these two process because the Dnsmasq daemon restarts twice
      remove-dnsmasq-toggle-conf public netflix_allow
      create-dnsmasq-toggle-conf public netflix
      # create-iptables-toggle-conf public 132_netflix
      ;;
    "allow")
      cron-daemonctl stop observe-netflix-conf "$safe"
      cron-daemonctl stop observe-netflix-allow-conf "$safe"
      # create-dnsmasq-toggle-conf public netflix_allow
      # remove-dnsmasq-toggle-conf public netflix
      # remove-iptables-toggle-conf public 132_netflix
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

observe() {
  case "$operation" in
    "start")
      cron-daemonctl start observe-crontab "$safe"
      cron-daemonctl start observe-cron-conf "$safe"
      cron-daemonctl start observe-dnsmasq-conf "$safe"
      cron-daemonctl start observe-dnsmasq-priv-conf "$safe"
      cron-daemonctl start observe-netplan-conf "$safe"
      cron-daemonctl start observe-dnsmasq-toggle "$safe"
      cron-daemonctl start observe-dnsmasq-priv-toggle "$safe"
      ;;
    "stop")
      # Do nothing if "schedules_update_ready" doesn't return "1" or "-1".
      if [ "$(schedules_update_ready)" -lt 0 ]; then
        # TODO: Please delete this note below after confirming the phenomenon doesn't happen.
        # Note that the same phenomenon could happen as [firewall_memo].
        cron-daemonctl start observe-crontab "$safe"
        cron-daemonctl start observe-cron-conf "$safe"
        cron-daemonctl start observe-dnsmasq-conf "$safe"
        cron-daemonctl start observe-dnsmasq-priv-conf "$safe"
        cron-daemonctl start observe-netplan-conf "$safe"
        cron-daemonctl start observe-dnsmasq-toggle "$safe"
        cron-daemonctl start observe-dnsmasq-priv-toggle "$safe"
      elif [ "$(schedules_update_ready)" -gt 0 ]; then
        cron-daemonctl stop observe-crontab "$safe"
        cron-daemonctl stop observe-cron-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-conf "$safe"
        cron-daemonctl stop observe-netplan-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-toggle "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-toggle "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

ometeotl() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-ometeotl-conf "$safe"
      create-dnsmasq-toggle-conf private ometeotl
      # create-iptables-toggle-conf private 234_ometeotl
      ;;
    "allow")
      :
      cron-daemonctl stop observe-ometeotl-conf "$safe"
      # remove-dnsmasq-toggle-conf private ometeotl
      # remove-iptables-toggle-conf private 234_ometeotl
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

periodic() {
  # Auto-update cron conf
  cron-apply perform

  # Observe IP address not getting lost
  sudo ip-observer

  # Observe the system clock not lagging
  clock-observer

  # Auto-update specific Git repositories
  #
  # While this script doesn't take effect while "git pull" is disabled by "observe-firewall",
  # it's important because settings that aren't changed automatically, especially the strict setting changes,
  # might not be changed for a while.
  #
  auto-git-pull                                  \
    "/home/ubuntu/workspace/cron-conf"           \
    "/home/ubuntu/workspace/dnsmasq-conf"        \
    "/home/ubuntu/workspace/envsman"             \
    "/home/ubuntu/workspace/systemd-units"       \
    "/home/ubuntu/workspace/diary"               \
    "/home/ubuntu/workspace/diary/_private"      \
    "/home/ubuntu/workspace/diary/_daily_report" &

  digital-detox-notifier

  auto-ufw-enabler

  # Auto-connect the devices paired with Bluetooth (only the first successful connection after the Bluetooth daemon starts)
  if [ -e "/home/ubuntu/.tmp/marlin_autoconnect" ]; then
    if [ "$(marlin info all --only iPhone,Mac | grep -c "Connected: no")" -ne 0 ]; then
      marlin autoconnect all --retry 2 --only iPhone,Mac
    else
      [ -e "/home/ubuntu/.tmp/marlin_autoconnect" ] && rm "/home/ubuntu/.tmp/marlin_autoconnect"
    fi
  fi
}

snorlax() {
  case "$operation" in
    "deny")
      # cron-daemonctl start observe-snorlax-conf "$safe"
      create-dnsmasq-toggle-conf public snorlax
      ;;
    "allow")
      # cron-daemonctl stop observe-snorlax-conf "$safe"
      remove-dnsmasq-toggle-conf public snorlax
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

startup() {
  log-reboot
  clock-observer
  metronome set full
  marlin autoconnect all --retry 2 --only iPhone,Mac # --log /home/ubuntu/.log/bluetooth_autoconnect.log
  search-stoppable-observer-daemons --skip --delay 30
}

superman() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-superman-conf "$safe"
      create-dnsmasq-toggle-conf private superman
      # create-iptables-toggle-conf private 233_superman
      ;;
    "allow")
      cron-daemonctl stop observe-superman-conf "$safe"
      # remove-dnsmasq-toggle-conf private superman
      # remove-iptables-toggle-conf private 233_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

todo() {
  case "$operation" in
    "start")
      cron-daemonctl start observe-dnsmasq-todo-list "$safe"
      cron-daemonctl start observe-dnsmasq-priv-todo-list "$safe"
      ;;
    "stop")
      cron-daemonctl stop observe-dnsmasq-todo-list "$safe"
      cron-daemonctl stop observe-dnsmasq-priv-todo-list "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

upstream() {
  # "cloudflare_upstream" or "superman_upstream"
  PRIORITY="superman_upstream"
  NON_PRIORITY="cloudflare_upstream"

  # Every upstream DNS file should be updated in succession without any interval.
  # When the previous file is deleted and the new file is not yet created, none of the upstream DNS files will be set, and the Internet connection will be blocked.
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-adguard-upstream-conf "$safe"
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-nordvpn-upstream-conf "$safe"
      remove-dnsmasq-toggle-conf private adguard_upstream --skip
      remove-dnsmasq-toggle-conf private nordvpn_upstream

      # Do nothing if either of them exists, even if the existing one is not prioritized,
      # because sometimes you may want to use the non-prioritized one.
      if [ -e "$PRIV_TOGGLE_DIR/$PRIORITY.conf" ] && [ -e "$PRIV_TOGGLE_DIR/$NON_PRIORITY.conf" ]; then
        remove-dnsmasq-toggle-conf private "$NON_PRIORITY"
      elif ! [ -e "$PRIV_TOGGLE_DIR/$PRIORITY.conf" ] && ! [ -e "$PRIV_TOGGLE_DIR/$NON_PRIORITY.conf" ]; then
        create-dnsmasq-toggle-conf private "$PRIORITY"
      fi
      ;;
    "allow")
      cron-daemonctl stop observe-adguard-upstream-conf "$safe"
      cron-daemonctl stop observe-nordvpn-upstream-conf "$safe"
      # remove-dnsmasq-toggle-conf private cloudflare_upstream --skip
      # remove-dnsmasq-toggle-conf private nordvpn_upstream    --skip
      # remove-dnsmasq-toggle-conf private superman_upstream   --skip
      # create-dnsmasq-toggle-conf private adguard_upstream
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

vod() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-vod-conf "$safe"
      create-dnsmasq-toggle-conf public vod
      # create-iptables-toggle-conf public 133_vod
      ;;
    "allow")
      cron-daemonctl stop observe-vod-conf "$safe"
      # remove-dnsmasq-toggle-conf public vod
      # remove-iptables-toggle-conf public 133_vod
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-conf "$safe"
      create-dnsmasq-toggle-conf public youtube
      # create-iptables-toggle-conf public 134_youtube
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-conf "$safe"
      # remove-dnsmasq-toggle-conf public youtube
      # remove-iptables-toggle-conf public 134_youtube
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_alternative() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-alternative-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_alternative
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-alternative-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_alternative
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_music() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-music-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_music
      # remove-iptables-toggle-conf public 135_youtube_music
      ;;
    "allow")
      :
      cron-daemonctl stop observe-youtube-music-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_music
      # create-iptables-toggle-conf public 135_youtube_music
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

#
# Returns false if the number of days given by TOOK_THRESHOLD has not elapsed since the cron file was updated on GitHub.
#
# Note that if the changes to a cron file are made on GitHub during the time when "scheduler firewall allow" and/or
# "scheduler observe stop" are performed, then the observers start working again without the "--safe" option,
# which means you get punished.
#
schedules_update_ready() {
  BASE_URL="https://api.github.com/repos"
  OWNER="noraworld"
  DAY_SECOND="86400"
  TOOK_THRESHOLD="0"

  local_cron_conf_updated_at=$(git -C "/home/ubuntu/workspace/cron-conf" --no-pager log -1 --format="%ct")
  local_dnsmasq_conf_updated_at=$(git -C "/home/ubuntu/workspace/dnsmasq-conf" --no-pager log -1 --format="%ct")
  local_priv_dnsmasq_conf_updated_at=$(git -C "/home/ubuntu/workspace/envsman" --no-pager log -1 --format="%ct")

  # https://docs.github.com/en/rest/commits/commits?apiVersion=2022-11-28
  cron_conf_updated_at=$(gh api "$BASE_URL/$OWNER/cron-conf/commits?per_page=1"       --jq ".[].commit.author.date")
  dnsmasq_conf_updated_at=$(gh api "$BASE_URL/$OWNER/dnsmasq-conf/commits?per_page=1" --jq ".[].commit.author.date")
  priv_dnsmasq_conf_updated_at=$(gh api "$BASE_URL/$OWNER/envsman/commits?per_page=1" --jq ".[].commit.author.date")

  latest_timestamp=$(echo "$(date -d"$cron_conf_updated_at" +%s) $(date -d"$dnsmasq_conf_updated_at" +%s) $(date -d"$priv_dnsmasq_conf_updated_at" +%s)" | tr ' ' '\n' | sort -n | tail -n 1)
  updated_at=$(date --date "@$latest_timestamp")

  took_seconds=$(( $(date +%s) - latest_timestamp ))
  took_days=$(( took_seconds / DAY_SECOND ))

  if [ "$1" = "schedules-update-ready" ]; then
    HOUR_SECOND="3600"
    DAY_HOUR="24"
    MINUTE_SECOND="60"
    HOUR_MINUTE="60"

    if [ "$VERBOSE" = "1" ]; then
      echo "[DEBUG] updated at:  $(date -d"$updated_at")"
      echo "[DEBUG] now:         $(date)"
    fi

    echo "[DEBUG] took:        $(printf "%01s" "$took_days"                                                       ) days"    \
                              "$(printf "%02s" "$(( took_seconds / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                              "$(printf "%02s" "$(( took_seconds / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                              "$(printf "%02s" "$(( took_seconds % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"

    echo "[DEBUG] passes over: $(printf "%01s" "$TOOK_THRESHOLD") days" \
                              "$(printf "%02s" "0") hours"              \
                              "$(printf "%02s" "0") minutes"            \
                              "$(printf "%02s" "0") seconds"

    if [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
      if [ "$local_cron_conf_updated_at" = "$(date -d"$cron_conf_updated_at" +%s)" ] &&
         [ "$local_dnsmasq_conf_updated_at" = "$(date -d"$dnsmasq_conf_updated_at" +%s)" ] &&
         [ "$local_priv_dnsmasq_conf_updated_at" = "$(date -d"$priv_dnsmasq_conf_updated_at" +%s)" ]; then

        echo "[DEBUG] left:        up to date!"
      else
        echo "[DEBUG] left:        ready to update!"
      fi
    else
      echo "[DEBUG] left:        $(printf "%01s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / DAY_SECOND                                  ))") days"    \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"
    fi

    printf "[DEBUG] result:      "
  fi

  if [ "$updated_at" = "" ]; then
    # Failed to retrieve information.
    echo "0"
    return
  elif [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
    # Enough time has passed that you can update the cron.
    echo "1"
  else
    # Not enough time has passed to allow cron to be updated.
    echo "-1"
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: scheduler [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    SAFE       --safe    -- "not getting punished"
  flag    SOFT       --soft    -- "deny resources without starting a daemon"
  flag    VERBOSE    --verbose -- "show detailed information"
  disp    :usage  -h --help    -- "show help message and exit"
  disp    VERSION    --version -- "show current version"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
SAFE=''
SOFT=''
VERBOSE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--safe')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SAFE="$OPTARG"
        ;;
      '--soft')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SOFT="$OPTARG"
        ;;
      '--verbose')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        VERBOSE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: scheduler [options]... [arguments]...

Options:
      --safe                  not getting punished
      --soft                  deny resources without starting a daemon
      --verbose               show detailed information
  -h, --help                  show help message and exit
      --version               show current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
