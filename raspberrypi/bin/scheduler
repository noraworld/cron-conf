#!/bin/sh
# shellcheck disable=SC2004

XDG_RUNTIME_DIR="/run/user/$(id -u)"

main() {
  export XDG_RUNTIME_DIR

  service="$1"
  operation="$2"

  parse "$@"
  eval "set -- $REST"

  if [ "$SAFE" = 1 ]; then
    safe="--safe"
  else
    # shellcheck disable=SC2034
    safe=""
  fi

  case "$service" in
    "amazon")
      amazon
      ;;
    "chime")
      chime
      ;;
    "dawn")
      dawn
      ;;
    "deregulated-superman")
      deregulated_superman
      ;;
    "deregulated-superman-allow")
      deregulated_superman_allow
      ;;
    "firewall")
      firewall
      ;;
    "focus")
      focus
      ;;
    "gaming")
      gaming
      ;;
    "github-editor")
      github_editor
      ;;
    "midnight")
      midnight
      ;;
    "morning")
      morning
      ;;
    "netflix")
      netflix
      ;;
    "observe")
      observe
      ;;
    "ometeotl")
      ometeotl
      ;;
    "periodic")
      periodic
      ;;
    "schedules-update-ready")
      schedules_update_ready "$@"
      ;;
    "snorlax")
      snorlax
      ;;
    "startup")
      startup
      ;;
    "superman")
      superman
      ;;
    "todo")
      todo
      ;;
    "upstream")
      upstream
      ;;
    "vod")
      vod
      ;;
    "youtube")
      youtube
      ;;
    "youtube-alternative")
      youtube_alternative
      ;;
    "youtube-music")
      youtube_music
      ;;
    *)
      echo "error: no such service: \"$service\"" >&2
      exit 1
      ;;
  esac
}

amazon() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-amazon-conf "$safe"
      create-dnsmasq-toggle-conf public amazon
      # create-iptables-toggle-conf public 131_amazon
      ;;
    "allow")
      cron-daemonctl stop observe-amazon-conf "$safe"
      remove-dnsmasq-toggle-conf public amazon
      # remove-iptables-toggle-conf public 131_amazon
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

chime() {
  case "$operation" in
    "deny")
      create-dnsmasq-toggle-conf public chime
      ;;
    "allow")
      remove-dnsmasq-toggle-conf public chime
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

# DEPRECATED: moved to "morning"
midnight() {
  clean-repo perform                                                  \
    "/home/ubuntu/workspace/cron-conf"                                \
    "/home/ubuntu/workspace/dnsmasq-conf/dnsmasq"                     \
    "/home/ubuntu/workspace/envsman/raspberrypi/dnsmasq/dnsmasq.priv" \
    "/home/ubuntu/workspace/envsman/raspberrypi/etc/netplan"
}

# DEPRECATED: moved to "morning"
dawn() {
  vpnctl disconnect --skipdns
  sudo systemctl restart diary
}

morning() {
  metronome set full

  # if [ "$(marlin info all --only iPhone,Mac | grep -c "Connected: no")" -ne 0 ]; then
  # shellcheck disable=SC3009
  systemctl --user restart pipewire{,-pulse}.{socket,service}
  sudo systemctl restart bluetooth
  # fi

  vpnctl disconnect --skipdns
  sudo systemctl restart diary

  clean-repo perform                                                  \
    "/home/ubuntu/workspace/cron-conf"                                \
    "/home/ubuntu/workspace/dnsmasq-conf/dnsmasq"                     \
    "/home/ubuntu/workspace/envsman/raspberrypi/dnsmasq/dnsmasq.priv" \
    "/home/ubuntu/workspace/envsman/raspberrypi/etc/netplan"
}

deregulated_superman() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-conf "$safe"
      create-dnsmasq-toggle-conf private deregulated_superman
      # create-iptables-toggle-conf private 231_deregulated_superman
      ;;
    "allow")
      :
      cron-daemonctl stop observe-deregulated-superman-conf "$safe"
      # remove-dnsmasq-toggle-conf private deregulated_superman
      # remove-iptables-toggle-conf private 231_deregulated_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

deregulated_superman_allow() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-deregulated-superman-allow-conf "$safe"
      remove-dnsmasq-toggle-conf private deregulated_superman_allow
      ;;
    "allow")
      :
      cron-daemonctl stop observe-deregulated-superman-allow-conf "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

firewall() {
  # Observe a firewall blocking the DNS port
  #
  # How to check if it works fine:
  #
  #   Make sure the following command returns 0
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   Then execute the following command
  #     $ sudo iptables -A FORWARD -p udp -m udp --dport 53 -j ACCEPT
  #
  #   Perform the following command again and make sure it returns 1
  #     $ sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT"
  #
  #   If it works properly, the result of the above command should be reset to 0 when the observer is executed
  #
  case "$operation" in
    "deny")
      cron-daemonctl start observe-firewall "$safe"
      ;;
    "allow")
      if [ "$(schedules_update_ready)" -ge 1 ]; then
        cron-daemonctl stop observe-firewall "$safe"
      else
        # MEMO:
        #   Note that when the firewall observer stops once but the todo observer is still working,
        #   and if communication with GitHub fails, this is performed and results in getting punished.
        #   [firewall_memo]
        cron-daemonctl start observe-firewall "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

focus() {
  case "$operation" in
    "deny")
      # cron-daemonctl start observe-focus-conf "$safe"
      create-dnsmasq-toggle-conf private focus
      # create-iptables-toggle-conf private 232_focus
      ;;
    "allow")
      # cron-daemonctl stop observe-focus-conf "$safe"
      remove-dnsmasq-toggle-conf private focus
      # remove-iptables-toggle-conf private 232_focus
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

gaming() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-gaming-conf "$safe"
      create-dnsmasq-toggle-conf public gaming
      ;;
    "allow")
      cron-daemonctl stop observe-gaming-conf "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

github_editor() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-github-editor-conf "$safe"
      create-dnsmasq-toggle-conf public github_editor
      ;;
    "allow")
      cron-daemonctl stop observe-github-editor-conf "$safe"
      remove-dnsmasq-toggle-conf public github_editor
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

netflix() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-netflix-conf "$safe"
      cron-daemonctl start observe-netflix-allow-conf "$safe"
      # it will take a few mintutes to finish these two process because the Dnsmasq daemon restarts twice
      remove-dnsmasq-toggle-conf public netflix_allow
      create-dnsmasq-toggle-conf public netflix
      # create-iptables-toggle-conf public 132_netflix
      ;;
    "allow")
      cron-daemonctl stop observe-netflix-conf "$safe"
      cron-daemonctl stop observe-netflix-allow-conf "$safe"
      # create-dnsmasq-toggle-conf public netflix_allow
      # remove-dnsmasq-toggle-conf public netflix
      # remove-iptables-toggle-conf public 132_netflix
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

observe() {
  case "$operation" in
    "start")
      cron-daemonctl start observe-crontab "$safe"
      cron-daemonctl start observe-cron-conf "$safe"
      cron-daemonctl start observe-dnsmasq-conf "$safe"
      cron-daemonctl start observe-dnsmasq-priv-conf "$safe"
      cron-daemonctl start observe-netplan-conf "$safe"
      cron-daemonctl start observe-dnsmasq-toggle "$safe"
      cron-daemonctl start observe-dnsmasq-priv-toggle "$safe"
      ;;
    "stop")
      if [ "$(schedules_update_ready)" -ge 1 ]; then
        cron-daemonctl stop observe-crontab "$safe"
        cron-daemonctl stop observe-cron-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-conf "$safe"
        cron-daemonctl stop observe-netplan-conf "$safe"
        cron-daemonctl stop observe-dnsmasq-toggle "$safe"
        cron-daemonctl stop observe-dnsmasq-priv-toggle "$safe"
      else
        # Note that the same phenomenon could happen as [firewall_memo].
        cron-daemonctl start observe-crontab "$safe"
        cron-daemonctl start observe-cron-conf "$safe"
        cron-daemonctl start observe-dnsmasq-conf "$safe"
        cron-daemonctl start observe-dnsmasq-priv-conf "$safe"
        cron-daemonctl start observe-netplan-conf "$safe"
        cron-daemonctl start observe-dnsmasq-toggle "$safe"
        cron-daemonctl start observe-dnsmasq-priv-toggle "$safe"
      fi
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

ometeotl() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-ometeotl-conf "$safe"
      create-dnsmasq-toggle-conf private ometeotl
      # create-iptables-toggle-conf private 234_ometeotl
      ;;
    "allow")
      :
      cron-daemonctl stop observe-ometeotl-conf "$safe"
      # remove-dnsmasq-toggle-conf private ometeotl
      # remove-iptables-toggle-conf private 234_ometeotl
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

periodic() {
  # Auto-update cron conf
  cron-apply perform

  # Observe IP address not getting lost
  sudo ip-observer

  # Observe the system clock not lagging
  clock-observer

  # Auto-connect all devices paired with Bluetooth (if not connected)
  marlin autoconnect all --retry 2 --only iPhone,Mac # --log /home/ubuntu/.log/bluetooth_autoconnect.log

  # Auto-update specific Git repositories
  #
  # While this script doesn't take effect while "git pull" is disabled by "observe-firewall",
  # it's important because settings that aren't changed automatically, especially the strict setting changes,
  # might not be changed for a while.
  #
  auto-git-pull                                  \
    "/home/ubuntu/workspace/cron-conf"           \
    "/home/ubuntu/workspace/dnsmasq-conf"        \
    "/home/ubuntu/workspace/envsman"             \
    "/home/ubuntu/workspace/systemd-units"       \
    "/home/ubuntu/workspace/diary"               \
    "/home/ubuntu/workspace/diary/_private"      \
    "/home/ubuntu/workspace/diary/_daily_report" &

  digital-detox-notifier

  auto-ufw-enabler
}

snorlax() {
  case "$operation" in
    "deny")
      # cron-daemonctl start observe-snorlax-conf "$safe"
      create-dnsmasq-toggle-conf public snorlax
      ;;
    "allow")
      # cron-daemonctl stop observe-snorlax-conf "$safe"
      remove-dnsmasq-toggle-conf public snorlax
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

startup() {
  log-reboot
  clock-observer
  metronome set full
  marlin autoconnect all --retry 2 --only iPhone,Mac # --log /home/ubuntu/.log/bluetooth_autoconnect.log
  search-stoppable-observer-daemons --skip --delay 30
}

superman() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-superman-conf "$safe"
      create-dnsmasq-toggle-conf private superman
      # create-iptables-toggle-conf private 233_superman
      ;;
    "allow")
      cron-daemonctl stop observe-superman-conf "$safe"
      # remove-dnsmasq-toggle-conf private superman
      # remove-iptables-toggle-conf private 233_superman
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

todo() {
  case "$operation" in
    "start")
      cron-daemonctl start observe-dnsmasq-todo-list "$safe"
      cron-daemonctl start observe-dnsmasq-priv-todo-list "$safe"
      ;;
    "stop")
      cron-daemonctl stop observe-dnsmasq-todo-list "$safe"
      cron-daemonctl stop observe-dnsmasq-priv-todo-list "$safe"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

upstream() {
  # Every upstream DNS file should be updated in succession without any interval.
  # When the previous file is deleted and the new file is not yet created, none of the upstream DNS files will be set, and the Internet connection will be blocked.
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-adguard-upstream-conf "$safe"
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-nordvpn-upstream-conf "$safe"
      remove-dnsmasq-toggle-conf private adguard_upstream    --skip
      remove-dnsmasq-toggle-conf private cloudflare_upstream --skip
      remove-dnsmasq-toggle-conf private nordvpn_upstream    --skip
      create-dnsmasq-toggle-conf private superman_upstream
      ;;
    "allow")
      cron-daemonctl stop observe-adguard-upstream-conf "$safe"
      cron-daemonctl stop observe-nordvpn-upstream-conf "$safe"
      # remove-dnsmasq-toggle-conf private cloudflare_upstream --skip
      # remove-dnsmasq-toggle-conf private nordvpn_upstream    --skip
      # remove-dnsmasq-toggle-conf private superman_upstream   --skip
      # create-dnsmasq-toggle-conf private adguard_upstream
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

vod() {
  case "$operation" in
    "deny")
      cron-daemonctl start observe-vod-conf "$safe"
      create-dnsmasq-toggle-conf public vod
      # create-iptables-toggle-conf public 133_vod
      ;;
    "allow")
      cron-daemonctl stop observe-vod-conf "$safe"
      # remove-dnsmasq-toggle-conf public vod
      # remove-iptables-toggle-conf public 133_vod
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-conf "$safe"
      create-dnsmasq-toggle-conf public youtube
      # create-iptables-toggle-conf public 134_youtube
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-conf "$safe"
      # remove-dnsmasq-toggle-conf public youtube
      # remove-iptables-toggle-conf public 134_youtube
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_alternative() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-alternative-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_alternative
      ;;
    "allow")
      cron-daemonctl stop observe-youtube-alternative-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_alternative
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

youtube_music() {
  case "$operation" in
    "deny")
      [ "$SOFT" = 1 ] || cron-daemonctl start observe-youtube-music-conf "$safe"
      remove-dnsmasq-toggle-conf public youtube_music
      # remove-iptables-toggle-conf public 135_youtube_music
      ;;
    "allow")
      :
      cron-daemonctl stop observe-youtube-music-conf "$safe"
      # create-dnsmasq-toggle-conf public youtube_music
      # create-iptables-toggle-conf public 135_youtube_music
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

#
# Returns false if the number of days given by TOOK_THRESHOLD has not elapsed since the cron file was updated on GitHub.
#
# Note that if the changes to a cron file are made on GitHub during the time when "scheduler firewall allow" and/or
# "scheduler observe stop" are performed, then the observers start working again without the "--safe" option,
# which means you get punished.
#
schedules_update_ready() {
  OWNER="noraworld"
  REPO="cron-conf"
  CRON_FILE="raspberrypi/schedules.cron"
  DAY_SECOND="86400"
  TOOK_THRESHOLD="3"

  #
  # TODO:
  #   This checks a cron file only.
  #   This check is incomplete because it doesn't detect the temporary changes to the Dnsmasq configuration files.
  #
  # https://stackoverflow.com/questions/15831313/is-it-possible-to-get-commits-history-for-one-file-in-github-api#answer-15838387
  #
  updated_at=$(gh api "https://api.github.com/repos/$OWNER/$REPO/commits?path=$CRON_FILE&per_page=1" \
                  --jq ".[].commit.author.date")

  took_seconds=$(( $(date +%s) - $(date -d"$updated_at" +%s) ))
  took_days=$(( took_seconds / DAY_SECOND ))

  if [ "$1" = "schedules-update-ready" ]; then
    HOUR_SECOND="3600"
    DAY_HOUR="24"
    MINUTE_SECOND="60"
    HOUR_MINUTE="60"

    echo "[DEBUG] updated at:  $(date -d"$updated_at")"
    echo "[DEBUG] now:         $(date)"

    echo "[DEBUG] took:        $(printf "%01s" "$took_days"                                                       ) days"    \
                              "$(printf "%02s" "$(( took_seconds / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                              "$(printf "%02s" "$(( took_seconds / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                              "$(printf "%02s" "$(( took_seconds % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"

    echo "[DEBUG] passes over: $(printf "%01s" "$TOOK_THRESHOLD") days" \
                              "$(printf "%02s" "0") hours"              \
                              "$(printf "%02s" "0") minutes"            \
                              "$(printf "%02s" "0") seconds"

    if [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
      echo "[DEBUG] left:        ready to update!"
    else
      echo "[DEBUG] left:        $(printf "%01s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / DAY_SECOND                                  ))") days"    \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / HOUR_SECOND   % DAY_HOUR                    ))") hours"   \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) / MINUTE_SECOND % HOUR_MINUTE                 ))") minutes" \
                                "$(printf "%02s" "$(( (TOOK_THRESHOLD * DAY_SECOND - took_seconds) % DAY_SECOND    % HOUR_SECOND % MINUTE_SECOND ))") seconds"
    fi

    printf "[DEBUG] result:      "
  fi

  if [ "$updated_at" = "" ]; then
    # Failed to retrieve information.
    echo "0"
    return
  elif [ "$took_days" -ge "$TOOK_THRESHOLD" ]; then
    # Enough time has passed that you can update the cron.
    echo "1"
  else
    # Not enough time has passed to allow cron to be updated.
    echo "-1"
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: scheduler [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    SAFE       --safe    -- "not getting punished"
  flag    SOFT       --soft    -- "deny resources without starting a daemon"
  disp    :usage  -h --help    -- "show help message and exit"
  disp    VERSION    --version -- "show current version"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
SAFE=''
SOFT=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--safe')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SAFE="$OPTARG"
        ;;
      '--soft')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SOFT="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: scheduler [options]... [arguments]...

Options:
      --safe                  not getting punished
      --soft                  deny resources without starting a daemon
  -h, --help                  show help message and exit
      --version               show current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
