#!/bin/sh

set -eu

main() {
  parse "$@"
  eval "set -- $REST"
  validate "$@"

  if [ "$FORCE" = "1" ]; then
    force="--force"
  else
    force=""
  fi

  keywords=$(printf '%s\n' "$@" | paste -sd '|')
  pattern='\\*\\s*\\[x\\].*\\[('"$keywords"')\\]\\(https://github.com/noraworld/diary-templates/issues/[0-9]*\\)'

  passed_count=$(eval "todo-cache --repo $REPO --past $PAST $force | grep -cE \"$pattern\"" || true)

  [ "$DEBUG" = "1" ] && echo "DEBUG: keywords: $keywords"     >&2
  [ "$DEBUG" = "1" ] && echo "DEBUG: pattern:  $pattern"      >&2
  [ "$DEBUG" = "1" ] && echo "DEBUG: past:     $PAST"         >&2
  [ "$DEBUG" = "1" ] && echo "DEBUG: argc:     $#"            >&2
  [ "$DEBUG" = "1" ] && echo "DEBUG: passed:   $passed_count" >&2

  if [ "$ZERO_STAMP" != "" ] && [ "$passed_count" -eq 0 ]; then
    echo "$ZERO_STAMP"
  elif [ "$PASS_STAMP" != "" ] && [ "$#" -eq "$passed_count" ]; then
    echo "$PASS_STAMP"
  elif [ "$FAIL_STAMP" != "" ] && [ "$#" -ne "$passed_count" ]; then
    echo "$FAIL_STAMP"
  elif [ "$MAXI_STAMP" != "" ] && [ "$passed_count" -gt 1 ]; then
    echo "$MAXI_STAMP"
  else
    echo "$passed_count"
  fi
}

validate() {
  if [ "$REPO" = "" ]; then
    echo "--repo is missing" >&2
    exit 1
  fi

  if [ "$PAST" = "" ]; then
    PAST=0
  fi

  # Delete if any problem doesn't happen.
  # if \
  #   { [ "$PASS_STAMP" != "" ] && [ "$FAIL_STAMP"  = "" ]; } ||
  #   { [ "$PASS_STAMP"  = "" ] && [ "$FAIL_STAMP" != "" ]; }
  # then
  #   echo "both --pass-stamp and --fail-stamp are necessary" >&2
  #   exit 1
  # fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: ticksum [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    DEBUG         --debug      -- "debug"
  param   FAIL_STAMP    --fail-stamp -- "[PRIORITY:2] return a given value instead of the number of checked tasks when not all the tasks have been passed"
  flag    FORCE         --force      -- "get todo list without cache"
  param   MAXI_STAMP    --maxi-stamp -- "[PRIORITY:3] return a given value if the actual result is more than 1"
  param   PASS_STAMP    --pass-stamp -- "[PRIORITY:2] return a given value instead of the number of checked tasks when all the tasks have been passed"
  param   PAST          --past       -- "past (default: 0)"
  param   REPO          --repo       -- "repo"
  param   ZERO_STAMP    --zero-stamp -- "[PRIORITY:1] return a given value instead of zero (none of the tasks has not been accomplished)"
  disp    :usage     -h --help
  disp    VERSION       --version
  msg -- ''
  msg -- 'Priority:'
  msg -- '      the lower the value, the higher the priority'
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
FAIL_STAMP=''
FORCE=''
MAXI_STAMP=''
PASS_STAMP=''
PAST=''
REPO=''
ZERO_STAMP=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '--fail-stamp')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        FAIL_STAMP="$OPTARG"
        shift ;;
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--maxi-stamp')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        MAXI_STAMP="$OPTARG"
        shift ;;
      '--pass-stamp')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        PASS_STAMP="$OPTARG"
        shift ;;
      '--past')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        PAST="$OPTARG"
        shift ;;
      '--repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        REPO="$OPTARG"
        shift ;;
      '--zero-stamp')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        ZERO_STAMP="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: ticksum [options]... [arguments]...

Options:
      --debug                 debug
      --fail-stamp FAIL_STAMP [PRIORITY:2] return a given value instead of the number of checked tasks when not all the tasks have been passed
      --force                 get todo list without cache
      --maxi-stamp MAXI_STAMP [PRIORITY:3] return a given value if the actual result is more than 1
      --pass-stamp PASS_STAMP [PRIORITY:2] return a given value instead of the number of checked tasks when all the tasks have been passed
      --past PAST             past (default: 0)
      --repo REPO             repo
      --zero-stamp ZERO_STAMP [PRIORITY:1] return a given value instead of zero (none of the tasks has not been accomplished)
  -h, --help
      --version

Priority:
      the lower the value, the higher the priority
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
