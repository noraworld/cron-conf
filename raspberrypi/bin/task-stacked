#!/bin/sh

# shellcheck disable=SC2004

NEW_DAY_OFFSET="8 hours ago"

export GHC_FROM="$(basename "$0") $*"

main() {
  prepare "$@"
  police "$@"

  validate "$@"

  [ "$PAST" = "" ] && PAST=0

  result="-2"

  if [ "$PAST" -eq 0 ] || [ "$INCLUDE_TODAY" = "1" ]; then
    check_list=$(
      todo-cache --repo "$MAIN_REPO" --date "$(date -d "$NEW_DAY_OFFSET" +%F)" "$force" "$cache_only" |
      awk '/## ðŸ¯ ä»Šæ—¥ã‚„ã‚‹ã“ã¨/{ flag=1; next } flag'
    )

    result=$(judge "$check_list")
    if [ "$DEBUG" = 1 ]; then
      echo "DEBUG: result (today)      = $result" >&2
      echo ""                           >&2
    fi
  fi

  if [ "$PAST" -ge 1 ]; then
    [ "$DEBUG" = 1 ] && ago="0"

    for i in $(seq 1 "$PAST"); do
      check_list=$(
        todo-cache --repo "$MAIN_REPO" --date "$(date -d "$i days ago $NEW_DAY_OFFSET" +%F)" "$force" "$cache_only" |
        awk '/## ðŸ¯ ä»Šæ—¥ã‚„ã‚‹ã“ã¨/{ flag=1; next } flag'
      )

      tmp_result=$(judge "$check_list")
      if [ "$tmp_result" -lt "$result" ]; then
        result="$tmp_result"
      fi

      if [ "$DEBUG" = 1 ]; then
        ago=$(( $ago + 1 ))

        if [ "$ago" -eq 1 ]; then
          echo "DEBUG: result ($ago day ago)  = $result" >&2
        else
          echo "DEBUG: result ($ago days ago) = $result" >&2
        fi

        echo "" >&2
      fi
    done
  fi

  print_result_end_exit
}

judge() {
  completed=$(
    echo "$1" |
    grep -cE "\* \[x\] \[.*\]\(https\:\/\/github\.com\/$(echo $TODO_REPO | sed -r "s|/|\\\/|g" | sed -E 's/,/|/g')\/issues\/[0-9]*\)"
  )
  stacked=$(
    echo "$1" |
    grep -cE "\* \[.\] \[.*\]\(https\:\/\/github\.com\/$(echo $TODO_REPO | sed -r "s|/|\\\/|g" | sed -E 's/,/|/g')\/issues\/[0-9]*\)"
  )
  nothing=$(
    echo "$1" |
    grep -cE "\* ç‰¹ã«ãªã—"
  )

  if [ "$DEBUG" = 1 ]; then
    echo "DEBUG: completed           = $completed" >&2
    echo "DEBUG: stacked             = $stacked"   >&2
    echo "DEBUG: nothing             = $nothing"   >&2
  fi

  if [ "$completed" -gt 0 ] && [ "$stacked" -gt 0 ] && [ "$completed" = "$stacked" ] && [ "$nothing" -eq 0 ]; then
    echo "2"
  elif [ "$stacked" -gt 0 ] && [ "$nothing" -eq 0 ]; then
    echo "1"
  elif [ "$stacked" -eq 0 ] && [ "$nothing" -eq 0 ]; then
    echo "0"
  else
    echo "-1"
  fi
}

print_result_end_exit() {
  if [ "$result" = "-2" ]; then
    echo "something went wrong" >&2
  fi

  echo "$result" > "$RESULT_FILE"

  # print nothing if the --fall-through option is passed and the result is zero or negative
  if [ "$FALL_THROUGH" = "" ] || [ "$result" -gt 0 ]; then
    echo "$result"
  fi

  if [ "$result" -gt 0 ]; then
    exit 0
  else
    exit 1
  fi
}

validate() {
  if [ "$(echo "$MAIN_REPO" | grep -cE ".*/.*")" -ne 1 ]; then
    echo "This is not a repository (MAIN_REPO)" >&2
    exit
  fi

  if [ "$STRICT" = "1" ] && ! ghc repo view "$MAIN_REPO" > /dev/null 2>&1; then
    echo "No repository found (MAIN_REPO)" >&2
    exit
  fi

  if [ "$(echo "$TODO_REPO" | grep -cE ".*/.*")" -ne 1 ]; then
    echo "This is not a repository (TODO_REPO)" >&2
    exit
  fi

  if [ "$STRICT" = "1" ] && ! ghc repo view "$TODO_REPO" > /dev/null 2>&1; then
    echo "No repository found (TODO_REPO)" >&2
    exit
  fi
}

prepare() {
  parse "$@"
  eval "set -- $REST"
  CHECK_FILE="/home/ubuntu/workspace/log/pi/tmp/task_stacked_$(echo "$MAIN_REPO" | cut -d '/' -f2 | tr '-' '_')_last_update"
  RESULT_FILE="/home/ubuntu/workspace/log/pi/tmp/task_stacked_$(echo "$MAIN_REPO" | cut -d '/' -f2 | tr '-' '_')_last_result"
  [ -e "$CHECK_FILE"  ] || date +%s  > "$CHECK_FILE"
  [ -e "$RESULT_FILE" ] || echo "-1" > "$RESULT_FILE"

  if [ "$FORCE" = "1" ]; then
    force="--force"
  else
    force=""
  fi

  if [ "$CACHE_ONLY" = "1" ]; then
    cache_only="--cache-only"
  else
    cache_only=""
  fi
}

police() {
  if [ "$(echo $(( $(date +%s) - $(cat "$CHECK_FILE") )) )" -lt 0 ]; then
    echo "An illegal timestamp was detected from the last update." >&2
    echo "-2" > "$RESULT_FILE"
    exit "2"
  fi
}

# shellcheck disable=SC2329
# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: task-stacked [options]... [arguments]..." ''
  msg -- 'Options:'
  flag  DEBUG            --debug         -- "perform as debug mode"
  flag  FALL_THROUGH     --fall-through  -- "do not print result if it is zero or negative (can be used with other scripts)"
  flag  FORCE            --force         -- "get content from APIs even if cache exists"
  flag  INCLUDE_TODAY    --include-today -- "whether to include today's task (only enabled when --past)"
  param MAIN_REPO        --main-repo     -- "main repo"
  flag  CACHE_ONLY       --cache-only    -- "use cache even if cache is stale (ignore check interval)"
  param PAST             --past          -- "get the past tasks instead of today"
  flag  STRICT           --strict        -- "check repo existence strictly"
  param TODO_REPO        --todo-repo     -- "todo repo"
  disp  :usage        -h --help
  disp  VERSION          --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
FALL_THROUGH=''
FORCE=''
INCLUDE_TODAY=''
MAIN_REPO=''
CACHE_ONLY=''
PAST=''
STRICT=''
TODO_REPO=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '--fall-through')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FALL_THROUGH="$OPTARG"
        ;;
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '--include-today')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        INCLUDE_TODAY="$OPTARG"
        ;;
      '--main-repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        MAIN_REPO="$OPTARG"
        shift ;;
      '--cache-only')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        CACHE_ONLY="$OPTARG"
        ;;
      '--past')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        PAST="$OPTARG"
        shift ;;
      '--strict')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        STRICT="$OPTARG"
        ;;
      '--todo-repo')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TODO_REPO="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: task-stacked [options]... [arguments]...

Options:
      --debug                 perform as debug mode
      --fall-through          do not print result if it is zero or negative (can be used with other scripts)
      --force                 get content from APIs even if cache exists
      --include-today         whether to include today's task (only enabled when --past)
      --main-repo MAIN_REPO   main repo
      --cache-only            use cache even if cache is stale (ignore check interval)
      --past PAST             get the past tasks instead of today
      --strict                check repo existence strictly
      --todo-repo TODO_REPO   todo repo
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
