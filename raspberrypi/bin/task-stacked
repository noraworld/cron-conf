#!/bin/sh

CHECK_FILE="/home/ubuntu/.tmp/task_stacked_last_update"
CHECK_INTERVAL="900"
RESULT_FILE="/home/ubuntu/.tmp/task_stacked_last_result"

export GHC_FROM="$(basename "$0") $*"

main() {
  prepare "$@"
  police "$@"

  if [ "$(updatable)" -lt 0 ]; then
    echo "It has not taken $CHECK_INTERVAL seconds since the last update." >&2
    cat "$RESULT_FILE"
    exit "1"
  fi

  result=$(ghc issue view               \
    --repo "noraworld/reserved-diary"   \
    $(ghc issue list                    \
      --repo "noraworld/reserved-diary" \
      --limit 1                         |
      awk '{ print $1 }'                \
    )                                   \
    --json body                         \
    --jq .body                          |
    awk '/## 🐯 今日やること/{ flag=1; next } flag'
  )

  completed=$(echo "$result" | grep -cE "\* \[x\] \[.*\]\(https\:\/\/github\.com\/noraworld\/to\-do\/issues\/[0-9]*\)")
  stacked=$(echo "$result" | grep -cE "\* \[.\] \[.*\]\(https\:\/\/github\.com\/noraworld\/to\-do\/issues\/[0-9]*\)")
  nothing=$(echo "$result" | grep -cE "\* 特になし")

  if [ "$DEBUG" = 1 ]; then
    echo "DEBUG: completed = $completed"
    echo "DEBUG: stacked   = $stacked"
    echo "DEBUG: nothing   = $nothing"
  fi

  if [ "$completed" -gt 0 ] && [ "$stacked" -gt 0 ] && [ "$completed" = "$stacked" ] && [ "$nothing" -eq 0 ]; then
    echo "2" > "$RESULT_FILE"
    echo "2"
  elif [ "$stacked" -gt 0 ] && [ "$nothing" -eq 0 ]; then
    echo "1" > "$RESULT_FILE"
    echo "1"
  elif [ "$stacked" -eq 0 ] && [ "$nothing" -eq 0 ]; then
    echo "0" > "$RESULT_FILE"
    echo "0"
  else
    echo "-1" > "$RESULT_FILE"
    echo "-1"
  fi
}

updatable() {
  if [ "$(cat "$RESULT_FILE")" -eq 0 ] ||
     [ "$(echo $(( $(date +%s) - $(cat "$CHECK_FILE") )) )" -gt "$CHECK_INTERVAL" ]; then

    date +%s > "$CHECK_FILE"
    echo "1"
  else
    echo "-1"
  fi
}

prepare() {
  parse "$@"
  eval "set -- $REST"
  [ "$FORCE" = 1 ] && CHECK_INTERVAL="0"
  [ -e "$CHECK_FILE"  ] || date +%s  > "$CHECK_FILE"
  [ -e "$RESULT_FILE" ] || echo "-1" > "$RESULT_FILE"
}

police() {
  if [ "$(echo $(( $(date +%s) - $(cat "$CHECK_FILE") )) )" -lt 0 ]; then
    echo "An illegal timestamp was detected from the last update." >&2
    echo "-2" > "$RESULT_FILE"
    exit "2"
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: task-stacked [options]... [arguments]..." ''
  msg -- 'Options:'
  flag DEBUG      --debug   -- "perform as debug mode"
  flag FORCE      --force   -- "ignore CHECK_INTERVAL"
  disp :usage  -h --help
  disp VERSION    --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DEBUG=''
FORCE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--debug')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DEBUG="$OPTARG"
        ;;
      '--force')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        FORCE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: task-stacked [options]... [arguments]...

Options:
      --debug                 perform as debug mode
      --force                 ignore CHECK_INTERVAL
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
