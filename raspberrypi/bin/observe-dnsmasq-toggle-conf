#!/bin/sh

set -u
export PATH=/home/ubuntu/workspace/cron-conf/bin:/home/ubuntu/.local/share/zinit/polaris/bin:"$PATH"
PROG_NAME=$(basename "$0")
RETRY_INTERVAL=1



observe() {
  observed_file=$(basename "$observed_path")

  if [ "$FILE" = "" ]; then
    file=$observed_file
  else
    file=$FILE
  fi

  if [ "$file" = "$observed_file" ]; then
    case "$EVENT" in
      "create")
        case "$MODE" in
          "link")
            sudo unlink "$TARGET/$file"
            # exrd is inappropriate here because the file is createable while it waits for the daemon to restart
            sudo systemctl restart dnsmasq
            echo "INFO: Deleted symlink \"$TARGET/$file\" automatically"
            ;;
          "cron")
            echo "ERROR: The combination of mode \"$MODE\" and event \"$EVENT\" is illegal." >&2
            exit 1
            ;;
        esac
        ;;
      "delete")
        case "$MODE" in
          "link")
            sudo ln -s "$SOURCE/$file" "$TARGET"
            # exrd is inappropriate here because the file is deleteable while it waits for the daemon to restart
            sudo systemctl restart dnsmasq
            echo "INFO: Created symlink \"$TARGET/$file\" automatically"
            ;;
          "cron")
            ca
            ;;
        esac
        ;;
      "modify")
        case "$MODE" in
          "link")
            echo "ERROR: The combination of mode \"$MODE\" and event \"$EVENT\" is illegal." >&2
            exit 1
            ;;
          "cron")
            ca
            ;;
        esac
        ;;
      *)
        case "$MODE" in
          "file")
            while [ "$(git -C "$TARGET" status --porcelain)" != "" ]; do
              # untracked new files
              if [ "$(git -C "$TARGET" status --porcelain | grep "^??")" != "" ]; then
                git -C "$TARGET" clean -df
              fi

              # tracked new files
              if [ "$(git -C "$TARGET" status --porcelain | grep "^A")" != "" ]; then
                git -C "$TARGET" restore --staged .
                git -C "$TARGET" clean -df
              fi

              # tracked modified or deleted files
              if [ "$(git -C "$TARGET" status --porcelain | grep -e "^M" -e "^D")" != "" ]; then
                git -C "$TARGET" restore --staged .
                git -C "$TARGET" restore .
              fi

              # untracked modified or deleted files
              if [ "$(git -C "$TARGET" status --porcelain | grep -e "^ M" -e "^ D")" != "" ]; then
                git -C "$TARGET" restore .
              fi

              sleep "$RETRY_INTERVAL"
            done
            ;;
          *)
            echo "Error: the combination of event $EVENT and mode $MODE is not supported" >&2
            exit 2
          ;;
        esac
        ;;
    esac
  fi
}



main() {
  parse "$@"
  eval "set -- $REST"
  validate "$@"

  # shellcheck disable=SC2086
  if [ "$SUDO" = "1" ]; then
    sudo inotifywait -e "$EVENT" --format '%w%f' -m -q -r -t 0 --exclude "\.git" "$TARGET" | while read -r observed_path; do
      observe
    done
  else
    inotifywait -e "$EVENT" --format '%w%f' -m -q -r -t 0 --exclude "\.git" "$TARGET" | while read -r observed_path; do
      observe
    done
  fi
}



validate() {
  if [ "$EVENT" = "" ]; then
    echo "ERROR: --event not set" >&2
    exit 1
  fi

  if [ "$SOURCE" = "" ]; then
    if [ "$EVENT" = "delete" ] && [ "$MODE" != "cron" ]; then
      echo "ERROR: --source not set" >&2
      exit 1
    fi
  fi

  if [ "$TARGET" = "" ]; then
    echo "ERROR: --target not set" >&2
    exit 1
  fi

  if [ "$MODE" = "" ]; then
    echo "ERROR: --mode not set" >&2
    exit 1
  elif [ "$MODE" != "link" ] && [ "$MODE" != "file" ] && [ "$MODE" != "cron" ]; then
    echo "ERROR: Unrecognized mode: $MODE" >&2
    exit 1
  fi
}



# @getoptions
parser_definition() {
  setup REST help:usage -- "Usage: observe-dnsmasq-toggle-conf [options]... [arguments]..." ""
  msg -- "Options:"
  param  EVENT   -e --event   -- "TBD"
  param  FILE    -f --file    -- "observe only a specific file (all files in a directory by default)"
  param  SOURCE  -s --source  -- "TBD"
  param  TARGET  -t --target  -- "target directory to observe (current directory by default)"
  flag   SUDO       --sudo    -- "TBD"
  param  MODE    -m --mode    -- "link, file, cron"
  disp   :usage  -h --help    -- "print help message and exit"
  disp   VERSION    --version -- "show the current version"
}
# @end



# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
EVENT=''
FILE=''
SOURCE=''
TARGET=''
SUDO=''
MODE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[efstm]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" "${OPTARG#??}"' ${1+'"$@"'}
        ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '-e'|'--event')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        EVENT="$OPTARG"
        shift ;;
      '-f'|'--file')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        FILE="$OPTARG"
        shift ;;
      '-s'|'--source')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        SOURCE="$OPTARG"
        shift ;;
      '-t'|'--target')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        TARGET="$OPTARG"
        shift ;;
      '--sudo')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SUDO="$OPTARG"
        ;;
      '-m'|'--mode')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        MODE="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: observe-dnsmasq-toggle-conf [options]... [arguments]...

Options:
  -e, --event EVENT           TBD
  -f, --file FILE             observe only a specific file (all files in a directory by default)
  -s, --source SOURCE         TBD
  -t, --target TARGET         target directory to observe (current directory by default)
      --sudo                  TBD
  -m, --mode MODE             link, file, cron
  -h, --help                  print help message and exit
      --version               show the current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end



main "$@"
