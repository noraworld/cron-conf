#!/bin/sh
# shellcheck disable=SC2004

main() {
  parse "$@"
  eval "set -- $REST"
  authenticate

  operation="$1"

  case "$operation" in
    "deny")
      deny "$@"
      ;;
    "allow")
      allow "$@"
      ;;
    *)
      echo "error: no such operation: \"$operation\"" >&2
      exit 1
      ;;
  esac
}

deny() {
  if ! eval "$(dns_blocked)" || ! eval "$(github_blocked)"; then
    restore_rules
    restrict_github

    if [ "$SAFE" != 1 ]; then
      punish "$@"
    fi
  fi
}

allow() {
  if eval "$(github_blocked)"; then
    restore_rules
  fi
}

restore_rules() {
  # Reset all rules
  printf "*filter\nCOMMIT\n*nat\nCOMMIT\n" | sudo iptables-restore

  # Apply UFW rules
  #   https://github.com/noraworld/ufw-conf
  sudo ufw reload
}

restrict_github() {
  # Retrieve all IP addresses for GitHub and extract ones used for "git"
  # e.g. 192.30.252.0/22,185.199.108.0/22,140.82.112.0/20,143.55.64.0/20,2a0a:a440::/29,2606:50c0::/32,20.201.28.151/32,20.205.243.166/32,20.87.225.212/32,20.248.137.48/32,20.207.73.82/32,20.27.177.113/32,20.200.245.247/32,20.233.54.53/32,20.201.28.152/32,20.205.243.160/32,20.87.225.214/32,20.248.137.50/32,20.207.73.83/32,20.27.177.118/32,20.200.245.248/32,20.233.54.52/32
  github_git_addresses=$(curl -s https://api.github.com/meta | tr -d '\n' | grep -oP "\"git\": \[(.*?)\]" | sed 's/"git": \[//g' | tr -d ']' | tr -d '"' | tr -d ' ')

  # e.g. 192.30.252.0/22,185.199.108.0/22,140.82.112.0/20,143.55.64.0/20,20.201.28.151/32,20.205.243.166/32,20.87.225.212/32,20.248.137.48/32,20.207.73.82/32,20.27.177.113/32,20.200.245.247/32,20.233.54.53/32,20.201.28.152/32,20.205.243.160/32,20.87.225.214/32,20.248.137.50/32,20.207.73.83/32,20.27.177.118/32,20.200.245.248/32,20.233.54.52/32
  github_git_ip4addresses=$(echo "$github_git_addresses" | perl -pe 's|[0-f]{1,4}:{1,2}[0-f]{1,4}.*?,||g')

  # e.g. 2a0a:a440::/29,2606:50c0::/32
  github_git_ip6addresses=$(echo "$github_git_addresses" | grep -oP "[0-f]{1,4}:{1,2}.*?," | tr -d '\n' | sed 's/,$/\n/g')

  # Block "git push" & "git pull" (only on this computer)
  # Try "git pull" at any Git directory to make sure if it works properly
  sudo iptables  -I OUTPUT -p all -d "$github_git_ip4addresses" -j REJECT
  sudo ip6tables -I OUTPUT -p all -d "$github_git_ip6addresses" -j REJECT
}

dns_blocked() {
  # Avoid invalid context length argument with grep
  #   https://stackoverflow.com/a/34077672/13999144

  # Check if the drop rule against 53/TCP forwarding exists
  if [ "$(sudo iptables-save | grep -ce "-A ufw-user-forward -p tcp -m tcp --dport 53 -j DROP")" -eq 0 ]; then
    echo false
    return
  fi

  # Check if the drop rule against 53/UDP forwarding exists
  if [ "$(sudo iptables-save | grep -ce "-A ufw-user-forward -p udp -m udp --dport 53 -j DROP")" -eq 0 ]; then
    echo false
    return
  fi

  # Check if the accepted rule against port 53 forwarding exists
  if [ "$(sudo iptables-save | grep -i "forward" | grep "53" | grep -c "ACCEPT")" -ge 1 ]; then
    echo false
    return
  fi

  echo true
}

github_blocked() {
  # Check if the GitHub IP addresses for "git push" & "git pull" are blocked
  # MEMO: "ssh -T git@github.com" can't be used
  git -C /home/ubuntu/workspace/cron-conf fetch > /dev/null 2>&1 && echo false && return

  echo true
}

punish() {
  sh -c "$(dirname "$(realpath "$0")")/../../bin/lib/punish"
}

authenticate() {
  IS_CRON_SCRIPT=$(dirname "$(realpath "$0")")/../../bin/lib/is-cron

  if [ "$(sh -c "$IS_CRON_SCRIPT")" = false ]; then
    echo "Fatal: This operation must be executed by cron, or this script does not take enough effect" >&2
    exit 2
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: observe-firewall [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    SAFE       --safe    -- "not getting punished"
  disp    :usage  -h --help    -- "show help message and exit"
  disp    VERSION    --version -- "show current version"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
SAFE=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--safe')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        SAFE="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: observe-firewall [options]... [arguments]...

Options:
      --safe                  not getting punished
  -h, --help                  show help message and exit
      --version               show current version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
