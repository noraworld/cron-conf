#!/bin/sh
# shellcheck disable=SC2004

PROG_NAME=$(basename "$0")
changed=false

main() {
  parse "$@"
  eval "set -- $REST"

  mode="$1"
  shift

  case "$mode" in
    "check")
      check "$@"
      ;;
    "perform")
      perform "$@"
      ;;
    *)
      echo "error: no such mode: \"$mode\"" >&2
      exit 1
      ;;
  esac
}

check() {
  result=""

  # shellcheck disable=SC1083
  for TARGET; do
    if [ "$(git -C "$TARGET" status --porcelain)"             != "" ] ||
       [ "$(git -C "$TARGET" rev-list HEAD@{upstream}..HEAD)" != "" ]; then

      if [ "$DETAIL" != "1" ]; then
        echo "-1"
        return
      fi

      result="${result}-1 "
    else
      result="${result}1 "
    fi
  done

  if [ "$DETAIL" = "1" ]; then
    echo "$result"
  else
    echo "1"
  fi
}

perform() {
  for TARGET; do
    # untracked new files
    if [ "$(git -C "$TARGET" status --porcelain | grep "^??")" != "" ]; then
      changed=true
      git -C "$TARGET" clean -df
    fi

    # tracked new files
    if [ "$(git -C "$TARGET" status --porcelain | grep "^A")" != "" ]; then
      changed=true
      git -C "$TARGET" restore --staged .
      git -C "$TARGET" clean -df
    fi

    # tracked modified or deleted files
    if [ "$(git -C "$TARGET" status --porcelain | grep -e "^M" -e "^D")" != "" ]; then
      changed=true
      git -C "$TARGET" restore --staged .
      git -C "$TARGET" restore .
    fi

    # untracked modified or deleted files
    if [ "$(git -C "$TARGET" status --porcelain | grep -e "^ M" -e "^ D")" != "" ]; then
      changed=true
      git -C "$TARGET" restore .
    fi

    # shellcheck disable=SC1083
    # already committed files
    if [ "$(git -C "$TARGET" rev-list HEAD@{upstream}..HEAD)" != "" ]; then
      changed=true
      #
      # shellcheck disable=SC2046
      #
      # For instance, "git reset --soft HEAD~2" reverts two commits back.
      #   https://stackoverflow.com/questions/7932222/how-to-revert-two-commits-back-and-commit-only-good-stuff#answer-7932255
      #   https://stackoverflow.com/questions/1463340/how-can-i-revert-multiple-git-commits#answer-43081965
      # "git rev-list HEAD@{upstream}..HEAD | wc -l | awk '{ print $1 }'" indicates how many commits have not been pushed.
      #   https://stackoverflow.com/questions/19206816/what-to-add-to-git-status-porcelain-to-make-it-behave-like-git-status#answer-19206916
      #
      git -C "$TARGET" reset --soft HEAD~$(git -C "$TARGET" rev-list HEAD@{upstream}..HEAD | wc -l | awk '{ print $1 }')
      git -C "$TARGET" restore --staged .
      git -C "$TARGET" restore .
    fi
  done

  if $changed; then
    if [ "$IMMEDIATELY" = 1 ]; then
      sudo systemctl restart dnsmasq
    else
      # It is performed in the background.
      exrd --skip --log /home/ubuntu/workspace/log/pi/log/exrd.log --from "$PROG_NAME $*" &
    fi
  fi
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: clean-repo [options]... [arguments]..." ''
  msg -- 'Options:'
  flag    DETAIL         --detail      -- "show results for each directory"
  flag    IMMEDIATELY    --immediately -- "restart dnsmasq daemon immediately"
  disp    :usage      -h --help        -- "show help message and exit"
  disp    VERSION        --version     -- "show current version and exit"
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
DETAIL=''
IMMEDIATELY=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--detail')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        DETAIL="$OPTARG"
        ;;
      '--immediately')
        [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
        eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
        IMMEDIATELY="$OPTARG"
        ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: clean-repo [options]... [arguments]...

Options:
      --detail                show results for each directory
      --immediately           restart dnsmasq daemon immediately
  -h, --help                  show help message and exit
      --version               show current version and exit
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
